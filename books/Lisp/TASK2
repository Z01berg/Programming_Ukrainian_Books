Визначення функцiй в Лiспi

Поряд з примiтивними функцiями можуть iснувати функцiї, визначенi
користувачем. Функцiя викликається набором аргументiв i повертає єдине 
значення. Визначення функцiї в Лiспi має наступний вигляд:

(DEFUN name (arg1 arg2 ...)
task1
task 2
. . . . .  )

де name - iм'я функцiї, arg1, arg2, ... - аргументи (параметри). Тiло функцiї 
мiстить послiдовнiсть задач. Ключове слово DEFUN виникло з DEfine FUNction. 

$ (DEFUN FIRST (lst)		$ (FIRST '(q w e r t y))
  (CAR lst) )			q

$ (DEFUN THIRD (lst)		$ (THIRD '(q w e r t y))
   (CADDR lst) )		e

Визначимо функцiю NULL, яка розпiзнає порожнiй список. Вона повертає iстину, 
якщо її аргументом є порожнiй список i хибнiсть в iншому випадку.

$ (DEFUN NULL (obj)	$ (NULL '(q w e r)) 	$ (NULL (CDR '(r)))
   (EQL obj NIL) )	F			T

Нам вже вiдомi три функцiї розпiзнання: EQL, ATOM, NULL. Функцiї, якi 
застосовуються для перевiрки певних умов та можуть повертати лише два 
значення - iстини чи хиби, називаються предикатами.

Тiло функцiї складається з послiдовностi завдань. Завдання можуть бути двох 
типiв: простi та умовними. Будь-яке завдання береться в круглi дужки i може 
розглядатися як список виразiв, якi треба проiнтерпретувати. 

Якщо завдання є атомом або його перший елемент є атомом, то таке завдання 
називається простим. Наприклад, (CONS 'NR LST).

Якщо перший елемент списка, який описує завдання не є атомом, то таке завдання 
називається умовним. Наприклад, ((ATOM lst) (CONS expr lst)). 

В умовному завданнi перший елемент списку обов'язково є предикатом. Якщо 
значення предикату NIL, то значення завдання стає рiвним NIL i Лiсп переходить 
до виконання наступного завдання. Якщо предикат повертає не NIL, вiдбувається 
виконання хвосту списку завдання, а iншi завдання iгноруються. Якщо предикат
повертає Т, а хвiст завдання порожнiй, то результатом всiєї функцiї буде T.

Напишемо предикат, який розпiзнає списки. Якщо аргументом є список, то 
предикат повертає iстину, iнакше - хибнiсть. Функцiю LISTP можна 
проiнтерпретувати наступним чином: "Якщо obj є атомом, то повернути NIL, 
iнакше повернути T". 

$ (DEFUN LISTP (obj)		$ (DEFUN LISTP (obj)
   ((ATOM obj) NIL)		((NULL obj))
   T )				((ATOM obj) NIL)
				T )

В другiй колонцi написано предикат LISTP, який розпiзнає додатково порожнiй 
список (повертає iстину). Перше завдання є умовним, хвiст якого порожнiй. 
Його можна проiнтерпретувати так: перевiрити об'єкт obj на порожнiй список,
i якщо вiн є таким, передати як результат функцiї iстину. Немає потреби 
писати: ((NULL obj) T), оскiльки це те ж саме, що i ((NULL obj)). Останнiм 
завданням цих предикатiв є атом Т. Це означає, що якщо жодне з умовних 
завдань не виконане (лише за цiєї умови керування програмою дiйде до 
останнього завдання), то як результат функцiї повернути Т. Для другого 
визначення функцiї LISTP маємо:

$ (LISTP 'tree)	$ (LISTP '())	$ (LISTP '(q w e r t y))
NIL 		T		T

Для кращого розумiння роботи тiла функцiї та простих i умовних завдань 
розглянемо функцiю sm та результати, якi вона буде генерувати при певних 
вхiдних значеннях:

$ (DEFUN sm (lst)		$ (sm '())		$ (sm '(q w e))
   ((NULL lst) 10 1)		1			12
   (SETQ b 2)
   ((CDR lst) 12)		$ (sm '(i))		$ (sm 'g)
   (SETQ b 3) )			3			3

Як бачимо, пiсля виконання простого завдання керування завжди передається
наступному завданню (якщо таке є). Якщо предикат умовного завдання iстинний, 
то виконується його хвiст i повертається результат останнього виразу хвоста.

Вмонтована функцiя (LIST x1 ... xn) утворює та видає список, елементами якого
є x1, ..., xn. Якщо аргументи не заданi, результатом буде NIL.

$ (LIST 'a 'b 'c 'd)	$ (LIST 'a '(b c) 'd)	$ (LIST)
(a b c d)		(a (b c) d)		NIL

Напишемо функцiю MEMBER, яка має два аргументи: nam - символ та lst - список 
i яка повинна перевiрити чи належить символ списку. Iнтуїтивно необхiдно 
порiвняти символ з першим елементом списку, потiм з другим елементом i так 
далi. Проблема в такому розв'язку виникає в тому, що ми не знаємо наперед 
довжини списку. А якщо ми i знаємо цю довжину, i якщо вона велика, то тiло 
функцiї буде дуже великим. Така функцiя буде мати приблизно такий вигляд 
(перший стовпчик):

$ (DEFUN MEMBER (nam lst)		$ (DEFUN MEMBER (nam lst)
  ((EQL nam (FIRST lst)))			((NULL lst) NIL)
  ((EQL nam (SECOND lst)))			((EQL nam (CAR lst)) T)
  ((EQL nam (THIRD lst)))			(MEMBER nam (CDR lst)) )
  ((EQL nam (THIRD (CAR lst))))
  .  .  .  .  .  .  .  .  .  .  .  .  . .  .

Змiнимо наш пiдхiд до побудови функцiї. В другому стовпчику побудовано функцiю 
MEMBER, в основi якої лежить рекурсивний пiдхiд, який базується на наступних 
фактах:

1. Якщо список порожнiй (не має елементiв), то nam не належить списку.
2. Якщо nam дорiвнює головi списку, то nam належить списку.
3. Якщо nam не дорiвнює головi списку, то nam може належити списку тодi i 
   тiльки тодi коли nam належить хвосту списку.

Розглянемо двi рекурсивнi функцiї: REMBER (REMove memBER), яка має два 
аргументи - атом obj  та список lst i яка видаляє перше зустрiчання атома 
obj в списку lst. REMBER-ALL яка видаляє всi атоми obj в списку lst.

$ (DEFUN REMBER  (obj lst)		(DEFUN REMBER-ALL (obj lst)
((NULL lst) NIL)			((NULL lst) NIL)
((EQL obj (CAR lst)) (CDR lst))		((EQL obj (CAR lst))
(CONS (CAR lst)				(REMBER-ALL obj (CDR lst))
    (REMBER obj (CDR lst))) )		(CONS (CAR lst)
 					(REMBER-ALL obj (CDR lst))) )

Результат роботи цих функцiй проiлюструємо на прикладах:

$ (REMBER 'a '(q a w e r t a y))	$ (REMBER-ALL 'a '(q a w e r t a y))
(q w e r t a y)				(q w e r t y)

Примiтивна функцiя EQL використовується для порiвняння атомiв. Часто виникає 
потреба порiвнювати списки. Напишемо функцiю EQLIST, яка порiвнює списки. Її 
побудуємо на основi наступних фактiв:

1. Якщо перший список порожнiй, то, якщо i другий список порожнiй, повернути Т, iнакше повернути NIL (або просто повернути (NULL другого списку)).
2. Якщо другий список порожнiй, повернути NIL.
3. Якщо голова першого списку не дорiвнює головi другого списку, повернути NIL.
4. Перевiрити рiвнiсть хвостiв першого та другого спискiв.

$ (DEFUN EQLIST (lst1 lst2)			$ (DEFUN NOT (obj)
     ((NULL lst1) (NULL lst2))			(EQL obj NIL) )
     ((NULL lst2) NIL)
     ((NOT (EQL (CAR lst1) (CAR lst2))) NIL)
     (EQLIST (CDR lst1) (CDR lst2)) )

Функцiя NOT повертає NIL, якщо список не порожнiй i Т iнакше.

Розглянемо задачу об'єднання спискiв. Роботу функцiї APPEND, аргументами якої 
є два списки lst1 та lst2, можна описати наступним чином:

1. Якщо lst1 порожнiй, повернути lst2.
2. З'єднати голову першого списку зi списком, який отримано в результатi 
   об'єднання хвоста першого списку з другим списком.

$ (DEFUN APPEND (lst1 lst2)
   ((NULL lst1) lst2)
   (CONS (CAR lst1) (APPEND (CDR lst1) lst2)) )

Функцiя  (REVERSE lst1) обертає список lst1. Якщо вихiдний список порожнiй, 
то i результатом буде порожнiй список. Iнакше необхiдно об'єднати обернений 
хвiст вихiдного списку з його першим елементом. Оскiльки на вхiд другого 
аргумента функцiї APPEND повинен подаватися список, необхiдно з першого 
елемента списку зробити список, який складається лише з нього. Це виконує 
команда (CONS (CAR lst) NIL).

$ (DEFUN REVERSE (lst)
   ((NULL lst) NIL)
   (APPEND (REVERSE (CDR lst)) (CONS (CAR lst) NIL)) )

Напишемо функцiю REVERSE без використання функцiї APPEND. Для цього побудуємо 
функцiю REVERSE з двома аргументами на принципi обробки стеку. Вихiдний список
- стек символiв. Якщо вiн порожнiй, то i результуючий стек буде порожнiм. 
Iнакше взяти символ з вершини стеку i покласти його на другий стек. Другий 
стек при виклику повинен бути NIL: (REVER <list> NIL).

$ (DEFUN REVER (lst1 lst2)			$ (REVER '(q w e) NIL)
  ((NULL lst1) lst2)				(e w q)
  (REVER (CDR lst1) (CONS (CAR lst1) lst2)) )



Середовище системи muLisp 

Середовище muLisp або поточний стан системи складається з усiх активних на 
даний момент структур даних, значень змiнних та визначених функцiй. Команда 
SAVE зберiгає поточне середовище muLisp у виглядi SYS - файлу. Команда 
(SAVE 'C:HOME) зберiгає середовище в файл HOME.SYS на диску C. Пiсля успiшного 
виконання команди запису повертається Т, iнакше - NIL.

Середовище muLisp може бути завантажене за допомогою команди LOAD: 
(LOAD <file>). Якщо файл не знайдено, повертається NIL, iнакше жодне значення 
не повертається, а mulisp починає працювати з новим середовищем.



Трасировка функцiй в muLisp.

Мова програмування muLisp для трасировки має програму debug.lsp, яка 
завантажуэться в середовище Лiспу. Для того, щоб дозволити трасировку 
будь-якої функцiї необхiдно дати команду (TRACE-FUNCTION <func>). Якщо 
пiсля цього викликати функцiю function, то на екранi вiдобразиться шлях 
виконання функцiї. Команда (UNTRACE-FUNCTION <func>) забороняє трасировку 
функцiї <func>. Якщо в тiлi функцiї <func> iснує виклик iнших функцiй, i ми 
хочемо побачити їх трасировку, необхiдно дозволити їх трасировку. Вираз 
<func>=<value> в трасi означає те, що функцiя <func> повертає значення 
<value>.

Наприклад, пiсля команд (TRACE-FUNCTION APPEND) (APPEND '(q w e) '(r t y u)) 
на екранi вiдобразиться траса (спочатку перший стовпчик, потiм - другий):

APPEND [(q w e) (r t y u)]		APPEND = (r t y u)
APPEND [(w e) (r t y u)] 		APPEND = (e r t y u)
APPEND [(e) (r t y u)]			APPEND = (w e r t y u)
APPEND [NIL (r t y u)]			APPEND = (q w e r t y u)

Розглянемо трасу функцiї REVERSE з дозволом трасировки функцiї APPEND для 
виразу (REVERSE '(q w)) (спочатку перший стовпчик, потiм - другий):

REVERSE [(q w)]			REVERSE = (w)
REVERSE [(w)]			APPEND [(w), (q)]
REVERSE [NIL]			APPEND [NIL, (q)]
REVERSE = NIL			APPEND = (q)
APPEND [NIL, (w)]		APPEND = (w q)
APPEND = (w)			REVERSE = (w q)



Завдання.

1. Написати функцiю, яка знаходить:
a) третiй елемент четвертого пiдсписку г) останнiй атом лiнiйного списку
б) перший елемент другого пiдсписку    д) останнiй атом списку з пiдсписками
в) перший атом списку з пiдсписками    е)перевiряє належнiсть елемента до списку

2. Написати функцiю REVERSE, не використовуючи функцiй селектора та конструктора. Вказiвка: використайте функцiї PUSH та POP.

3. Написати функцiю, яка:
а) з вихiдного списку робить множину	в) знаходить рiзницю двох множин
б) об'єднує двi множини			г) знаходить перетин двох множин



II Варiант завдань

1. Написати функцiї:

а) (REVERSE_ALL lst), де lst - список з пiдсписками. Функцiя повертає обернений 
   на усiх рiвнях список lst.

$ (reverse_all '(1 2 3 (q w e (r t) y) 7 9))
(9 7 (Y (T R) E W Q) 3 2 1)

б) (FIND_NEIGHBOURS lst node), де lst - список ребер графу (ребро графу є 
   списком з двох чисел - номерiв вершин), node - номер вершини. Функцiя 
   повинна повернути список вершин, сумiжних з вершиною node. Граф вважати 
   неорiєнтованим.

$ (find_neighbours '((1 2) (3 1) (4 5) (9 1) (2 3) (1 5)) 1)
(2 3 9 5)

в) (LINER lst), де lst - список з пiдсписками. Лiнеризувати список lst.

$ (liner '(3 (q w e r (t) () y ) 4 (5) o (p () )))
(3 Q W E R T Y 4 5 O P)

г) (SYMDIFF lst1 lst2), де lst1 та lst2 - множини. Повернути їх симетричну 
   рiзницю.

$ (symdiff '(2 3 4 5) '(3 41 1 5))
(2 4 41 1)



Вiдповiдi.

1. a) $ (DEFUN F1 (lst)			б) $ (DEFUN F2 (lst)
          (CADDR (CADDDR lst)))  )	        (CAADR lst)  )
в) $ (DEFUN FATOM (lst)			г) $ (DEFUN LAST (lst)
       ((ATOM (CAR lst) (CAR lst))	       ((CDR lst) (LAST (CDR lst)))
       (FATOM (CAR lst))  )		       (CAR lst)  )
д) $ (DEFUN FLAST (lst)			е) $ (DEFUN IN (obj lst)
       ((ATOM lst) lst)			       ((NULL lst) NIL)
       ((CDR lst) (FLAST (CDR lst)))	       ((EQL obj (CAR lst)) T)
       (FLAST (CAR lst))  )		       (IN obj (CDR lst))  )

2. $ (DEFUN rev (lst1 lst2)
   ((NULL lst1) lst2)
   (PUSH (POP lst1) lst2)
   (REV lst1 lst2)  )
3. а) $ (DEFUN NO-DOUBLES(lst)
       (NULL lst) NIL)
       (CONS (CAR lst) (NO-DOUBLES (REMBER-ALL (CAR lst) lst)))  )
б) $ (DEFUN UNION (lst1 lst2)
       (NO-DOUBLES (APPEND lst1 lst2))  )
в) $ (DEFIN MINUS (lst1 lst2)
       ((NULL lst2) lst1)
       (MINUS (REMBER (CAR lst2) lst1) (CDR lst2))  )
г) $ (DEFUN INTERSECT (lst1 lst2)
      ((NULL lst1) NIL)
      ((IN (CAR lst1) lst2) (CONS (CAR lst1) (INTERSECT (CDR lst1) lst2)))
      (INTERSECT (CDR lst1) lst2)  )



II Варiант завдань

а) (DEFUN REVERSE_ALL (lst)
    	((NULL lst) NIL)
((ATOM (CAR lst)) (APPEND (REVERSE_ALL (CDR lst)) (CONS (CAR lst))))
(APPEND (REVERSE_ALL (CDR lst)) (CONS (REVERSE_ALL (CAR lst))))  )

б) (DEFUN find_neighbours (lst node)
((NULL lst) NIL)
((EQL (CAAR lst) node) (CONS (CADAR lst) (find_neighbours (CDR lst) node)))
((EQL (CADAR lst) node) (CONS (CAAR lst) (find_neighbours (CDR lst) node)))
(find_neighbours (CDR lst) node)  )

в) (DEFUN liner (lst)
((NULL lst) NIL)
((LISTP (CAR lst)) (APPEND (liner (CAR lst)) (liner (CDR lst))))
(CONS (CAR lst) (liner (CDR lst)))  )

г) (DEFUN symdiff (lst1 lst2)
        (UNION (minus lst1 lst2) (minus lst2 lst1))  )

