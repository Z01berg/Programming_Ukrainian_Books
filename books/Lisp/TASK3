Примiтивнi об'єкти даних

Примiтивними об'єктами даних є символи, числа та конси. muLisp має безлiч 
функцiй розпiзнання, порiвняння, комбiнування та обробки цих об'єктiв. Це 
дозволяє конструювати будь-якi складнi об'єкти даних. Як було сказано ранiше, 
muLisp має два типи даних: атоми та списки. Атоми подiляються на символи та 
числа. Списки є пiдмножиною об'єктiв, якi мають бiльш загальну структуру - 
бiнарне дерево. Вони створенi за допомогою консiв. 

Символ є об'єктом даних, з яким пов'зано 4 атрибути, кожен з яких є 
вказiвником на:

-  PRINT - iм'я. Це унiкальний рядок ASCII символiв, за допомогою якого 
   система iдентифiкує символ при операцiях введення-виведення. PRINT - iм'я 
   не може бути змiнене. Iмена обмеженi за розмiром: вони повиннi мати не 
   бiльше вiд 65536 символiв. 

- поточне значення. Значенням символа може бути будь-який об'єкт даних, який 
  зберiгається в комiрцi пам'ятi. Якщо в середовищi Лiспу ввести PRINT-iм'я 
  символу, то на виходi буде його значення. Поточне значення доступно як 
  CAR - елемент символа.

- список властивостей. Вiн мiстить значення властивостей символа, 
  проiндексованих за ключем, його форма має вигляд: 
  (iм'я1 значення1 iм'я2 значення2 ... iм'яN значенняN). 
  При iнiцiалiзацiї системи список властивостей є порожнiм (дорiвнює NIL).
  Його можна змiнити за допомогою функцiй властивостей та прапорцiв. 
  Доступний як CDR - елемент символа.

- визначення функцiї. При створеннi символу в muLisp цей атрибут дорiвнює 
  "функцiя невизначена". Визначення функцiї складається або за шаблонами 
  машинної мови, або на D-кодi. Значення цього атрибута можна отримати в 
  результатi виконання функцiї флагiв (GETD  символ).

SYMBOLP є функцiя, яка розпiзнає символ. Вона повертає Т, якщо аргумент є 
символом i NIL в протилежному випадку.

$ (SYMBOLP 'XYZ)		$ (SYMBOLP 41) 
T				NIL                     

$ (SYMBOLP '(q w))		$ (SYMBOLP '())
NIL				T

В Коммон Лiспi (файл common.lsp) визначенi функцiї SYMBOL-VALUE, яка повертає
значення символа, та функцiя SYMBOL-PLIST, яка повертає весь список 
властивостей символа.

(DEFUN SYMBOL-VALUE (SYM)		(DEFUN SYMBOL-PLIST (SYM)
((SYMBOLP SYM) (CAR SYM) ) )		((SYMBOLP SYM) (CDR SYM) ) )

Узагальненою функцiєю присвоєння є SETF, яка визначена в common.lsp. Вона 
заносить даннi в комiрку пам'ятi символа: (SETF <комiрка пам'ятi> <значення>). 
Через функцiю SETF можна представити описанi ранiше функцiї SET та SETQ.

(SETQ x y)	   	це	(SETF x y)
(SET x y)		це	(SETF (SYMBOL-VALUE x) y)

Промiжки, дужки, коми, одинарнi та подвiйнi лапки, крапка, крапка з комою 
вiдiграють спецiальну роль в Лiспi. Одинарним Escape-символом є \. 
Багатократним Еscape-символом є |. Спецiальнi лiтери можуть використовуватися 
у PRINT-iменах символiв, але для цього перед ними треба ставити \, або весь 
рядок брати в |. Вирази |q w e| та |sym(bol| є символами. Для використання 
лiтер \ та | в символах необхiдно ставити перед ними \. Якщо виводиться на 
екран символ, який мiстить спецiальнi лiтери, то вiн виводиться з багатократним 
escape-символом. Програмна змiнна *PRINT-ESCAPE* булевського типу вiдповiдає 
за виведення escape-символiв. Якщо вона дорiвнює NIL, то escape-символи на 
екран не виводяться. Подвiйнi лапки " грають роль лiтери |. Розглянемо 
приклади (спочатку *PRINT-ESCAPE*=T):

$ (SETQ |sym(bol| 3)	$ (SETQ a |q w e|)	$ s\a	$ s\\a
$ |sym(bol|		$ a			sa	|s\\a||
3                       |q w e|

$ (SETQ *PRINT-ESCAPE* NIL)	$ (SETQ a |q w e|)	$ (SETQ "s\\a" 2)
$ s\\a				$ a			$ |s\\a|
s\a				q w e			2

Число є iншим примiтивним об'єктом. Воно може бути цiлим або дробовим. 
Цiле число вводиться як послiдовнiсть цифр, перед якою може стояти знак мiнус. 
За внутрiшнiм поданням цiлi числа дiляться на малi цiлi (до 65536) та великi 
цiлi. Оскiльки значенням числа завжди є саме число, то немає необхiдностi 
перед ним ставити апостроф. Чотири атрибути характеризують число як об'єкт 
даних:

- елемент тотожностi. Це є вказiвник на саме число. Вiн доступний як 
  CAR-елемент числа.

- знак. Вiн мiстить один з наступних символiв, якi характеризують тип числа:

	додатне	вiд'ємне		$ (CDR 5.6)	$ (CAR 5.6)
мале	NIL	T			MACRO		5.6
велике	LAMBDA	NLAMBDA			$ (CDR 1212)	$ (CDR -121212)
дробове	MACRO	SPECIAL			NIL		NLAMBDA

Значення атрибута знака доступне як CDR-елемент числа.

- довжина. Якщо число є малим цiлим, то цей атрибут мiстить значення цiлого. 
  Якщо число - велике цiле, то елемент 'довжина' мiстить довжину слова вектора 
  числа. Якщо число дробове - елемент мiстить вказiвник на його чисельник, який 
  обов'язково повинен бути цiлим (додатним або вiд'ємним).

- вектор. Якщо число мале цiле, то значення атрибута є вказiвником на iнше мале 
  цiле (хеш-з'єднувач). Якщо число велике цiле, то це поле мiстить вказiвник на 
  найменший значущий байт. Якщо число дробове - елемент мiстить вказiвник на 
  його знаменник, який повинен бути додатним цiлим числом.

Функцiя порiвняння EQL може використовуватися для порiвняння чисел. Але бiльш 
загальною функцiєю для порiвняння множини чисел є рiвнiсть:

$ (EQL -3 4)	$ (EQL 4 4)	$ (= 2 2 2)	$ (= 2 2 3 2)
NIL		T		T		NIL

Дробовi числа можуть подаватися у десятковому виглядi та з дробовою рискою. 
Внутрiшня змiнна *PRINT-POINT* вiдповiдає за тип виведення дробових чисел. 
Якщо вона дорiвнює NIL, то всi дробовi числа подаються на виведення з дробовою 
рискою. Якщо *PRINT-POINT* = n, то дробовi числа виводяться з n знаками пiсля 
десяткової коми. При введеннi дробового числа воно автоматично скорочується.

$ 3/4	$ 3/9	$ 5/1	$ 12/9
3/4	1/3	5	4/3

Внутрiшня змiнна *PRINT-BASE* вiдповiдає за основу системи числення, в якiй обробляються числа. Якщо значення цiєї змiнної є цiлим та перебуває в iнтервалi вiд 2 до 32, то такою i буде основа системи числення, iнакше muLisp працює в десятковiй системi числення.

$ (SETQ ten 10)				$ (SETQ *PRINT-BASE* 2)	$ 234
$ (SETQ *PRINT-BASE* 16)		$ ten			11101010
$ ten					1010
0A

Функцiєю, яка розпiзнає цiлi числа, є INTEGERP. Вона повертає Т, якщо її 
аргумент є цiлим числом та NIL iнакше. Функцiя NUMBERP розпiзнає число.

$ (INTEGERP 100)	$ (INTEGERP 3.5)
T			NIL

$ (NUMBERP 3.5)		$ (NUMBERP 4/5)
T			T

Число в подвiйних лапках завжди є символом:

$ (SYMBOLP "23")	$ (NUMBERP "23")
T			NIL

Символи та числа є атомами. Наступнi вирази повертають iстину: 
(ATOM 3.5), (ATOM "23"), (ATOM 'APPLE).

Конс є примiтивним об'єктом, який вказує на будь-якi два iншi об'єкти даних.
Вiн не є атомом. Назва конс пiшла вiд функцiї конструктора CONS. Кожен конс 
складається з CAR- та CDR- елементiв. Конс часто називають точковою парою. 
Якщо X i Y об'єкти даних, то вираз (X . Y) є консом, CAR-елемент якого є X, 
а CDR-елемент - Y.

$ (SETQ A (cons X Y))	$ (CAR A)	$ (CDR A)	$ (CDR '(R . S))
$ A			X		Y		S
(X . Y)

За допомогою точкового подання можна показати структуру будь-якого об'єкту.
Список (x1 x2 x3) є ланцюгом консiв, якi зв'язанi за допомогою CDR- елементiв. 
Його CAR- елементи вказують на елементи списку. CDR- елемент останнього конса 
вказує на NIL. Вказаний список можна подати у виглядi (x1 . (x2 . (x3 . NIL))). 
Функцiя READ читання виразу розпiзнає як точкове подання виразу, так i спискове.
Функцiя виведення PRINT виводить об'єкти в списковому поданнi.

$ (SETQ a '(q . (w . nil))	$ a	$ (CONSP '(q . w))	$ (CONSP (q w))
(q w)				(q w)	T			T

Функцiя (CONSP obj) розпiзнає конси. Список не є примiтивним об'єктом, а є 
ланцюгом консiв. Отже, результатом застосування функцiї CONSP до списку буде Т.



Функцiї розпiзнання

Функцiї розпiзнання - це твердження, якi використовуються для розпiзнання 
або iдентифiкацiї об'єктiв даних muLisp. Цi функцiї мають тiльки один аргумент, 
а повертають булеве значення. Вони розпiзнають об'єкт, який може мати довiльну 
структуру. Ми вже розглянули деякi функцiї розпiзнання: SYMBOLP, INTEGERP, 
NUMBERP, ATOM, LISTP, NULL. Розглянемо iншi.

(ZEROP <obj>).   Повертає Т, якщо obj - число 0.
(PLUSP <obj>).   Повертає Т, якщо obj - додатне число.
(MINUSP <obj>).  Повертає Т, якщо obj - вiд'ємне число.
(ODDP <obj>).    Повертає Т, якщо obj - непарне цiле число.
(EVENP <obj>).   Повертає Т, якщо obj - парне цiле число.

Функцiя (ASCII <sym>) повертає ASCII-код символа <sym>. Функцiя (ASCII <num>) 
повертає символ, ASCII код якого дорiвнює числу <num>. Для того, щоб визначити, 
чи є символ sym лiтерою, можна використати функцiю:
(< (ASCII 'a) (ASCII sym) (ASCII 'z)). 

Оскiльки muLisp не розрiзняє малi та великi лiтери, то (ASCII 's) = (ASCII 'S)
для будь-якого символа s. Функцiя ISCHAR розпiзнає лiтери. Для знаходження ASCII 
кодiв символiв, якi позначають цифри, необхiдно використовувати одинарний 
Escape-символ.

$ (DEFUN ISCHAR (char)				$ (ASCII 'f)	$ (ASCII 70)
(<= (ASCII 'a) (ASCII char) (ASCII 'z)))	70		F

$ (ASCII '\9)		$ (ASCII 57)      
57			\9

Наступнi функцiї дають можливiсть розпiзнавати символи та числа.

(ALPHA-CHAR-P <obj>)   - повертає T, якщо <obj> - лiтера.
(NUMERIC-CHAR-P <obj>) - повертає T, якщо <obj> - цифра.
(ALPHANUMERICP <obj>)  - повертає T, якщо <obj> - лiтера або цифра.

$ (ALPHA-CHAR-P W)	$ (ALPHA-CHAR-P \3)	$ (ALPHA-CHAR-P ~)
T			NIL			NIL

$ (NUMERIC-CHAR-P W)	$ (NUMERIC-CHAR-P \3)	$ (NUMERIC-CHAR-P ~)
NIL			T			NIL

$ (ALPHANUMERICP W)	$ (ALPHANUMERICP \3)	$ (ALPHANUMERICP ~)
T			T			NIL

Зазначимо, що символ промiжку (' ')  є лiтерою.



Завдання 3-1

1. Перевiрити, чи складається список лише з:
а) рiвних чисел			г) додатних та вiд'ємних малих цiлих, якi чергуються
б) символiв			    через одне, причому їхня кiлькiсть парна
в) вiд'ємних дробових чисел	д) вiд'ємних парних цiлих чисел

2. Написати функцiю, яка за вхiдним списком будує необхiдну структуру:
а) (q w e r t y)	->	(q (w (e (r (t (y))))))
б) (q w e r t y		->	((((((y) t) r) e) w) q)
в) (q w e r t y)	->	((q) (w) (e) (r) (t) (y))
г) (q w e r t y)	->	((q w) (e r) (t y))

3. Написати функцiю, яка за списком який дано в завданнi 3 в другому стовпчику, 
будує лiнiйний список.

Вiдповiдi

1. a) $ (DEFUN EQNUM (lst)
      ((NULL (CDR lst)) T)
      ((NUMBERP (CAR lst)) ((EQL (CAR lst) (CADR lst)) (EQNUM (CDR lst))))  )
   б) $ (DEFUN SYMALL (lst)
       ((NULL lst) T)
       ((SYMBOLP (CAR lst)) (SYMALL (CDR lst)))  )
   в) $ (DEFUN DRIBVID (lst)
       ((NULL lst) T)
       ((EQL (CDAR lst) SPECIAL) (DRIBVID (CDR lst)))  )
    г) $ (DEFUN MINT (lst)
        ((NULL lst) T)
        ((NULL (CDR lst)) NIL)
        ((NOT (CDAR lst)) ((CDADR lst) (MINT (CDDR lst))))  )
    д) $ (DEFUN VIDPAR (lst)
        ((NULL lst) T)
        ((EVENP (CAR lst))  ((MINUSP (CAR lst)) (VIDPAR (CDR lst))))  )

2. a) $ (DEFUN ON1 (lst)
       ((ATOM (CDR lst)) (CONS (CAR lst) NIL))
       (CONS (CAR lst) (CONS (ON1 (CDR lst)) NIL))  )
   б) $ (DEFUN ON2 (lst)
       ((ATOM (CDR lst)) (CONS (CAR lst) NIL))
       (CONS (ON2 (CDR lst)) (CAR lst))  )
    в) $ (DEFUN ON3 (lst)
        ((ATOM (CDR lst)) (CONS (CONS (CAR lst) NIL) NIL))
        (CONS (CONS (CAR lst) NIL) (ON3 (CDR lst)))  )
    г) $ (DEFUN ON4 (lst)
        ((ATOM (CDDR lst))(CONS (CONS (CAR lst) (CONS (CADR lst) NIL)) NIL))
        (CONS (CONS (CAR lst) (CONS (CADR lst) NIL)) (ON4 (CDDR lst)))  )

3. a) $ (DEFUN RON1 (lst)       
       ((NULL lst) NIL)
       (CONS (CAR lst) (RON! (CADR lst)))  )
    б) $ (DEFUN RON2 (lst)
        ((ATOM (CAR lst)) lst)
        (CONS (CADR lst) (RON2 (CAR lst)))  ) 
     в) $ (DEFUN RON3 (lst)
         ((NULL lst) NIL)
         (CONS (CAAR lst) (RON3 (CDR lst)))  )
     г) $ (DEFUN RON4 (lst)
         ((NULL lst) NIL)
         (CONS (CAAR lst) (CONS (CADAR lst) (RON4 (CDR lst))))  )


Числовi функцiї.

Числовi функцiї виконують основнi математичнi операцiї над цiлими та дробовими 
числами. Користувач може обрати для роботи точну або наближену рацiональну 
арифметику. Для точної рацiональної арифметики розмiр цiлих чисел, чисельникiв 
та знаменникiв обмежений приблизно до 25000 десяткових знакiв. 
Примiтивними числовими функцiями є додавання, вiднiмання, множення та дiлення. 
В мовi програмування Лiсп вони є n-арними, тобто кiлькiсть їхнiх аргументiв 
необмежена. Синтаксис числових функцiй наступний:

1. (+ <num1> <num2> ... <numM>).  3. (* <num1> <num2> ... <numM>)
2. ( - <num1> <num2> ... <numM>)  4. (/ <num1> <num2> ... <numM>)

Функцiя додавання повертає суму своїх аргументiв. Функцiя вiднiмання повертає 
рiзницю першого аргумента та суми всiх iнших аргументiв. Функцiя множення 
повертає добуток своїх аргументiв. Функцiя дiлення повертає частку вiд дiлення 
першого аргумента та добутку iнших аргументiв.

$ (+ 2 4 6 7)	$ (- 20 3 5 6)	$ (* 2 4 6)	$ (/ 24 2 2 3)
19		6		48		2

Функцiї збiльшення та зменшення мають наступний синтаксичний вигляд:
1. (ADD1 <n>).	 Повертає значення, яке на одиницю бiльше за аргумент.
2. (SUB1 <n>).   Повертає значення, яке на одиницю менше за аргумент.
3. (INCQ <sym><n>)  Збiльшує значення символа <sym> на число <n>.
4. (DECQ <sym><n>) Зменшує значення символа <sym> на число <n>.

Якщо функцiю додавання (вiднiмання) одиницi запустити без аргументiв, то виникне переривання по помилцi: недостатня кiлькiсть аргументiв. Якщо у функцiю INCQ або DECQ передати один аргумент - символ, то збiльшення (зменшення) значення символа вiдбудеться на одиницю. Окрiм того, що функцiї INCQ та DECQ повертають результат арифметичної дiї, значення символiв, якi передаються до них як аргументи, змiнюється.
$ (ADD1 6)	$ (SUB1 10)	
7		9                   
$ (SETQ S 10)	$ (INCQ S 14)	$ (DECQ S 4)
10		24		30

Функцiї MIN та MAX повертають символ з вiдповiдно мiнiмальним (максимальним) значенням.
1. (MIN <n1> <n2> ... <nM>).	$ (MIN 12 3  45  67)	$ (MAX 1 2 5 3)
2. (MAX <n1> <n3> ... <nM>).	3			5

Числовi вирази в Лiспi записуються в префiкснiй формi. Вираз 3*5+5*7 для 
обчислення треба подати у виглядi (+ (* 3 5) (* 5 7)), вираз (3+6)*7 - у 
виглядi  (* (+ 3 6) 7). 

Функцiї порiвняння менше та бiльше мають n аргументiв.
1. ( < <n1> <n2> ... <nM>)	Повертає iстину, якщо <n1> < <n2> <  ... <  <nM>.
2. < ><n1> <n2> ... <nM>)	Повертає iстину, якщо <n1> > <n2> >  ... >  <nM>.
3. ( /= <n1> <n2> ... <nM>)	Повертає iстину, якщо iснують хоча б два числа, якi не 
				дорiвнюють одне одному.

До функцiй порiвняння також вiдносяться <= , = та >=.
$ (< 2 4 6)	$ (>= 5 3 3 2)	$ ( /= 4 4 5)
T		T		T
$ (< 6 6 8 15)	$ (<= 6 6 8 15)	$ ( /= 4 4 4)
NIL		T		NIL


1. Функцiї округлення
(TRUNCATE m n), (ROUND m n), (CEILING m n) (FLOOR m n)
Цi функцiї використовуються для округлення дробових чисел до цiлих. 
TRUNCATE виконує округлення до ближчого цiлого у напрямку нуля. ROUND 
виконує округлення до ближчого цiлого по значенню до m/n. CEILING виконує 
округлення до ближнього цiлого по верхнiй межi, FLOOR - по нижнiй межi. 
Виклик будь-якої функцiї з двома аргументами (<f> m n) еквiвалентний виклику 
функцiї з одним аргументом: (<f> (/ n m)), де f - будь-яка з наведених 
чотирьох функцiй.

$ (TRUNCATE 6/4)  $ (TRUNCATE -6/4)  $ (CEILING 9 4)	$ (CEILING -9 4)
1		  -1		     3			-2

$ (FLOOR 6 4)	$ (FLOOR -6 4)	$ (FLOOR 6/4)	$ (FLOOR -6/4)
1		-2		1		-2

2. Функцiї остачi
(REM m n), (MOD m n), (DIVIDE m n)
Примiтивна функцiя REM повертає остачу вiд дiлення числа m на n. 
Функцiя MOD працює як REM, але повертає модуль остачi. Якщо (TRUNCATE m n) 
повертає q, а (REM m n) повертає r, то m=q*n+r. Функцiя (DIVIDE m n) повертає 
конс, CAR якого дорiвнює частцi, а CDR - остачi вiд дiлення m на n.

$ (REM 6 4)	$ (DIVIDE 7 2)	$ (REM -6 4)	$ (MOD 6 4)
2		(3 . 1)		-2		2

3. Знак числа
(SIGNUM n)
Повертає значення -1, 0 або 1 якщо n вiдповiдно вiд'ємне, 0, або додатнє.

4. Модуль числа
 (ABS n) - Модуль числа n.

5. Чисельник та знаменник
(NUMERATOR n), (DENOMINATOR n) - чисельник та знаменник числа n.

$ (signum -5/3)	$ (abs -5/3)	$ (numerator 10/8)	$ (denominator 10/8 )
-1		5/3		5			4


6. Побiтовi логiчнi функцiї
(LOGAND <n1><n2>...<nM>), (LOGIOR <n1><n2>...<nM>), (LOGXOR <n1><n2>...<nM>), 
(LOGNOT n).

$ (LOGAND 5 7 3)	$ (LOGIOR 4 2 1)	$ (LOGXOR 5 2 3)   $ (LOGNOT 6)
1			7			4		    -7

7. Булевi функцiї
(NOT <об'єкт>), (AND <форма1> <форма2> ... <формаN>), (OR  <форма1> <форма2> ... <формаN).

$ (AND (EQL 'as 'as) (< 2 4))	$ (OR NIL (< 4 56))	$ (NOT (EQL 'd 'g))
T				T			T

8. Зсув. (SHIFT m n) - зсув числа m на n бiтiв.

$ (SHIFT 3 1)	$ (SHIFT 3 -1)	$ (GCD 24 66 600)	$ (LCM 24 66 600)
6		1		6			6600

9. НСД, НСК. (GCD n1 n2 ... nM), (LCM n1 n2 ... nM).  
Цi функцiї знаходять вiдповiдно найбiльший спiльний дiльник M чисел та 
найменше спiльне кратне.



Задача 1. Список lst має 100 елементiв, якi дорiвнюють 0 або 1. Написати функцiю 
(CHANGE01 lst), яка повертає список, у якому всi елементи 0 замiненi на 1, а 1 - на 0.
Необхiдно замiсть використання умовного оператора застосувати дiю X := 1 - X.

(DEFUN CHANGE01 (lst)
        ((NULL lst) NIL)
        (CONS (- 1 (CAR lst)) (CHANGE01 (CDR lst)))  )

Задача 2. Змiнним a та b присвоєнi числа. Записати функцiю в одному рядку 
(не визначати цю функцiю), в результатi якої змiннi обмiнюються своїми 
значеннями. Використовувати допомiжнi змiннi забороняється.

$ (SETQ a 2 b 3)				// a = 2, b = 3
$ (SETQ a (+ a b) b (- a b) a (- a b))		// a = 3, b = 2

Задача 3. Вiдомо, що lst - список, який мiстить неспадну послiдовнiсть чисел. 
Функцiя (NUM lst) повинна обчислювати кiлькiсть рiзних чисел у ньому.

(DEFUN NUM (lst)
        ((NULL (CDR lst)) 1)
        ((/= (CAR lst) (CADR lst)) (+ 1 (NUM (CDR lst))))
        (NUM (CDR lst))  )

Задача 4. Списки lst1 та lst2 мiстять строго зростаючi послiдовностi чисел. 
Знайти кiлькiсть спiльних елементiв у цих масивах. Часова оцiнка алгоритму 
повинна дорiвнювати O(K+L), де K та L - довжини спискiв lst1 та lst2 вiдповiдно.

(DEFUN COMELEMENT (lst1 lst2)
        ((OR (NULL lst1) (NULL lst2)) 0)
        ((< (CAR lst1) (CAR lst2)) (COMELEMENT (CDR lst1) lst2))
        ((> (CAR lst1) (CAR lst2)) (COMELEMENT lst1 (CDR lst2)))
        (+ 1 (COMELEMENT (CDR lst1) (CDR lst2)))  )


В файлi irratnal.lsp мiститься великий набiр iррацiональних та 
трансцендентних функцiй. Аргументи тригонометричних функцiй задаються в 
радiанах.

1. (EXP x)		експонента e^x
2. (EXPT x y)           степiнь x^y
3. (LOG x y)		логарифм logyx. Якщо y не задано, основа вважається рiвною e.
4. (LN x)		натуральний логарифм
5. (SQRT x)		квадратний корiнь
6. (ISQRT x)		цiла частина з квадратного кореня
7. (SIN x) та (ASIN x)	сiнус та арксiнус
8. (COS x) та (ACOS x)	косинус та арккосинус
9. (TAN x) та (ATAN x)	тангенс та арктангенс
10.(RANDOM n)	        генерується натуральне число, менше за n.


Контрольнi конструкцiї

MuLisp використовує неявну форму PROGN для обчислення форм, якi складають 
тiло функцiї. Окрiм того, iнтерпретатор muLisp розпiзнає в тiлi функцiї 
неявнi COND конструкцiї. Неявнi COND-и роблять визначення функцiй 
читабельними, короткими та ефективними. Спецiальнi форми забезпечують 
контроль за обчисленням форм в процесi виконання програм. Розглянемо деякi 
контрольнi iнструкцiї.

1. QUOTE <об'єкт> повертає об'єкт <obj> без його обчислення. QUOTE може 
   використовуватися для запобiгання обчислення значень констант, якi 
   передаються як аргумент функцiї, що обчислюється.


$ (SETQ a 125)
$ a		$ (QUOTE a)	$ (CAR (CONS 4 7))	$ (CAR '(CONS 4 7))
125		a		4			CONS

2. LOOP <форма1> <форма2> ... <формаN> Повторно обчислює форми у послiдовному 
   порядку доти, поки не зустрiнеться неявний COND з предикатом, не рiвним NIL. 
   Розглянемо функцiю LENGTH обчислення довжини списку. В першому стовпчику 
   запропоновано рекурсивний, в лiвому - нерекурсивний варiант програми.

(DEFUN LENGTHr (lst)		(DEFUN LENGTH (lst)
	((NULL lst) 0)			(SETQ ct 0)
	(+ 1 (LENGTHr (CDR lst)))  	(LOOP
)					((NULL lst) ct)
					(SETQ lst (CDR lst) ct (+ 1 ct))  
					)  )

3. IF <предикат> [THEN] <форма1> [ELSE] <форма2> Якщо значення предиката не 
   дорiвнює NIL, то видається [THEN] форма, iнакше видається [ELSE] форма.

$ (IF (EQL 'r 'r)	(CAR '(q w e r t y)) (CDR '(q w e r t y)))  -  q
$ (IF (EQL 'r 'w)	(CAR '(q w e r t y)) (CDR '(q w e r t y)))  -  (w e r t y)

4. IDENTITY <об'єкт> Повертає об'єкт без жодних змiн. Ця функцiя застосовується 
   для використання змiнних як предикатiв в умовних виразах.

5. PROGN <форма1> <форма2> ... <формаN> Послiдовно обчислює форми та повертає 
   результат обчислення формиN.

6. PROG1 <форма1> <форма2> ... <формаN> Послiдовно обчислює форми та повертає 
   результат обчислення форми1. Функцiю використовують для того, щоб вводити 
   допомiжнi змiннi для збереження результатiв в процесi обчислення iнших виразiв.

$ (SETQ a '(q w e r t y))		$ a
$ (PROG1 (CAR a) (SETQ a (CDR a)))	(w e r t y)
q

7. COND <cond1> <cond2> ... <condN> Обчислює CAR кожної COND форми доти, доки 
   не зустрiнеться деяке значення, вiдмiнне вiд NIL, або доки всi предикати не 
   будуть обчисленi. В першому випадку COND обчислює CDR елемент cons - форми 
   з предикатом, який не дорiвнює NIL, як тiло функцiї, використовуючи неявну 
   функцiю PROGN. Якщо CDR - елемент COND форми, яка не дорiвнює NIL, є 
   порожнiм, то повертається значення предиката. Якщо обчисленi всi предикати 
   та всi вони повернули NIL, то COND повертає NIL.

8. COMMENT <коментар> Iгнорує свої аргументи та повертає NIL. Визначає засiб 
   включення коментарiв безпосередньо у визначенi функцiї.

9. RETURN <об'єкт> Зупиняє виконання функцiї, яка мiстить RETURN, звiльняє 
   стек та повертає об'єкт в ролi свого значення.

10. RESTART Закриває всi вiдкритi файли, вiдмовляється вiд поточного 
    середовища та iнiцiює нову систему muLisp. Всi зв'язки мiж змiнними, 
    функцiї користувача та значення властивостей поточного середовища 
    знищуються.

11. SYSTEM Закриває всi вiдкритi файли, завершує виконання muLisp та повертає
    керування операцiйнiй системi.

12. EXECUTE <програма> <командний рядок> Зупиняється робота системи muLisp, 
    передається керування програмi з командним рядком. EXECUTE повертає код виходу 
    з програми або NIL, якщо <програма> не знайдена.

$ (EXECUTE "command.com" "/c dir c:")


Обчислення рекурсивних функцiй

1. Факторiалом числа n називається число (позначається n!), яке рекурсивно 
визначається наступним чином:

0! = 1			$ (DEFUN FACTORIAL (n)		$ (FACTORIAL 10)
N! = N*(N-1)! якщо N>0.	((ZEROP n) 1)			3628800
			(* n (FACTORIAL (- n 1)))  )

Якщо в рекурсивнiй програмi аргументом буде велике число, то може виникнути 
переповнення стеку. Використовуючи команду циклу LOOP можна уникнути 
екурсивного виклику. Наступна функцiя буде бiльш ефективною:

$ (DEFUN FACTORIAL1 (n rslt)		$ (FACTORIAL1 10)
(SETQ rslt 1)				3628800
(LOOP
         ((ZEROP n) rslt )		$ (FACTORIAL 0 a)
         (SETQ rslt (* n rslt))		1
         (SETQ n (- n 1))  )  )

2. Послiдовнiсть чисел, кожен елемент якої дорiвнює сумi двох попереднiх, а 
першi два елементи дорiвнюють 1, називається послiдовнiстю Фiбоначчi. N-те 
число послiдовностi Фiбоначчi F(N) може бути знайдене за рекурсивною формулою:

F(0)=1, F(1)=1, F(N) = F(N-1) + F(N-2).

$ (DEFUN FIBON (n)				$ (FIBON 20)
((<= n 1) 1)					10946
(+ (FIBON (- n 1)) (FIBON (- n 2)))  )

Визначена таким чином функцiя не є ефективною, оскiльки для обчислення N-ого 
числа Фiбоначчi необхiдно обчислити (N-2) число Фiбоначчi двiчi, (N-3) - тричi 
i так далi. Визначимо функцiю FIB з трьома аргументами, останнi два з яких при 
виклику функцiї повиннi дорiвнювати вiдповiдно F(0) та 0).

$ (DEFUN FIB (n f1 f2)			$ (FIB 20 1 0)
((ZEROP n) f1)				10946
(FIB (- n 1) (+ f1 f2) f1)  )


Завдання 3-2.

1. Визначити функцiї MIN, MAX, INCR, DECR для спискiв. 
Функцiя INCR (DECR) повертає iстину, якщо значення аргументiв знаходяться 
у зростаючому (спадному) порядку.

2. Написати функцiю, яка за списком з пiдсписками знаходить:
a) суму елементiв		в) кiлькiсть пiдспискiв
б) кiлькiсть елементiв		г) лiнеризує список

3. Написати функцiї:
a) (DIVIS x y) - повертає частку та остачу вiд дiлення x на y. Повернути результат  у виглядi конса. Не використовувати функцiй дiлення та остачi.
б) (POW x y)   - x в степенi y. Запропонувати алгоритми з часовою оцiнкою O(y) та O(log y).
в) (SLIST n)   - розклад числа n на простi множники. Як результат виконання функцiї повернути список простих чисел, добуток яких дорiвнює n.
г) (PERLEN n)  - за натуральним числом n повернути довжину перiоду дробу 1/n.
д) (SUMFACT n) - сума 1/0! + 1/1! + ... + 1/n!.

4. (UNITE lst1 lst2). Злити два неспаднi списки lst1 та lst2 в один неспадний список.

5. Написати функцiю:
а) (BINARY n) - кiлькiсть знакiв у двiйковому представленнi числа n.
б) НСД та НСК двох чисел за алгоритмом Евклiда.
    НСД(a, b) =	НСД(a - b, b), якщо a>b,
               	НСД(a, b - a), якщо a<b,
			    a, якщо a = b.
в) НСД двох чисел за модифiкованим алгоритмом Евклiда.
   НСД(a, b) =	НСД(a mod b, b), якщо a>b,
                НСД(a, b mod a), якщо a<b,
			a, якщо b = 0.
			b, якщо a = 0.
г) (INVERTBIT a n) - обернути n-ий бiт числа a.
д) (EQ2 a b c)  - розв'язати квадратне рiвняння.
е) (SQTR a b c) - знайти площу трикутника за трьома сторонами (використати формулу Герона).


Вiдповiдi

1. $ (DEFUN LMIN (lst)
   ((ATOM (CDR lst)) (CAR lst))
   ((< (CAR lst) (CADR lst)) (LMIN (CONS (CAR lst) (CDDR lst))))
   (LMIN (CDR lst))  )


$ (DEFUN LMAX (lst)
   ((ATOM (CDR lst)) (CAR lst))
   ((> (CAR lst) (CADR lst)) (LMAX (CONS (CAR lst) (CDDR lst))))
   (LMAX (CDR lst))  )

$ (DEFUN INCR (lst)
   ((ATOM (CDR lst)) T)
   ((< (CAR lst) (CADR lst)) (INCR (CDR lst)))  )

$ (DEFUN DECR (lst)
   ((ATOM (CDR lst)) T)
   ((> (CAR lst) (CADR lst)) (DECR (CDR lst)))  )

2. a) $ (DEFUN FSUM (lst)
       ((NULL lst) 0)
       ((ATOM (CAR lst)) (+ (CAR lst) (FSUM (CDR lst))))
       ( + (FSUM (CAR lst)) (FSUM (CDR lst))) )

   б) $ (DEFUN FLEN (lst)
       ((NULL lst) 0)
       ((ATOM (CAR lst)) (+ 1 (FLEN (CDR lst))))
       ( + (FLEN (CAR lst)) (FLEN (CDR lst))) )

   в) $ (DEFUN FLIST (lst)
       ((NULL lst) 0)
       ((ATOM (CAR lst)) (FLIST (CDR lst)))
       (+ 1 (FLIST (CAR lst)) (FLIST (CDR lst)))  )

   г) $ (DEFUN LINER (lst)
       ((NULL lst) NIL)
       ((ATOM (CAR lst)) (CONS (CAR lst) (LINER (CDR lst))))
       (APPEND (LINER (CAR lst)) (LINER (CDR lst)))  )

3. a) $ (DEFUN DIVIS (x y)		б1) $ (DEFUN POW (x y)
       ((ZEROP y) NIL)				((ZEROP y) 1)
       (SETQ ch 0)				(* (POW x (- y 1)) x)  )
       (LOOP
        ((< x y) (CONS ch x))
        (SETQ x (- x y) ch (+ 1 ch)))  )

б2)  $(DEFUN POWLOGY (x y)
(SETQ k y b 1 c x)
(LOOP
   ((= k 0) b)
   (if (= 0 (mod k 2)) (SETQ k (/ k 2) c (* c c))
(SETQ k (SUB1 k) b (* b c)) )
)  )

в) $ (DEFUN SLIST (n)			г) $ (DEFUN PERLEN (n)
      (SETQ k n lst NIL)			      (SETQ r 0 l 1)
      (LOOP					      (LOOP
       ((= k 1) lst)					((= l (+ n 1)))
       (SETQ l 2)					(SETQ r (CDR (divis (* 10 r) n)))
       (LOOP						(INCQ l)
           ((ZEROP (CDR (DIVIS k l))))	      )
           (INCQ l)				      (SETQ c r r (CDR (divis (* 10 r) n)) k 0)
       						      (LOOP
       (PUSH l lst)					((=  r c))
       (SETQ k (/ k l))				((SETQ r (CDR (divis (* 10 r) n))))
    )  )						(INCQ k)
)
(+ k 1)  )

д) (DEFUN SUMFACT (n)
       (SETQ k 1 fct 1 s 1)
       (LOOP
((= k n) s)
(SETQ k (INCQ k) fct (* fct k) s (+ s (/ 1 fct)))
       )   )

Пояснення. г) перiод дробу дорiвнює перiодовi в послiдовностi остач 
(доведiть це; зокрема, необхiдно довести, що вiн не може бути меншим). 
Окрiм цього, в цiй послiдовностi всi члени, що перiодично повторюються, 
рiзнi, а передперiод має довжину не бiльшу за n. Тому достатньо знайти 
(n+1)-й член послiдовностi остач i потiм мiнiмальне k, за якого (n+1+k)-й 
член	спiвпадає з (n+1)-м.

4. (DEFUN UNITE (lst1 lst2)
        ((NULL lst1) lst2)
        ((NULL lst2) lst1)
        ((<= (CAR lst1) (CAR lst2)) (CONS (CAR lst1) (UNITE (CDR lst1) lst2)))
        ((>  (CAR lst1) (CAR lst2)) (CONS (CAR lst2) (UNITE lst1 (CDR lst2))))  )

5. a) $ (DEFUN BINARY (n) 			б) (DEFUN NOD (a b)
 ((= n 0 ) 1)					   ((= a b) a)
 (SETQ c 0)					   (IF (> a b) (NOD (- a b) b)
 (LOOP							(NOD (- b a) a)
   ((= n 0) c) 					     )   )
   (SETQ n (SHIFT n -1)) (INCQ c)	           (DEFUN NOK (a b)
      )   )						   (/ (* a b) (NOD a b))   )

в) $ (DEFUN NODM (a b)			г) $ (DEFUN INVERTBIT (a n)
       ((ZEROP a) b)				(SETQ s (SHIFT 1 (SUB1 n)))
       ((ZEROP b) a)				(LOGXOR a s)
       (IF (> a b) (NODM (MOD a b) b)	     )
            (NODM (MOD b a) a)
       )   )

д) $ (LOAD 'irratnal)		          е) $ (DEFUN sqtr (a b c)
   $ (DEFUN eq2 (a b c)			         (SETQ p (/ (+ a b c) 2))
      (SETQ d (- (* b b) (* 4 a c)))		 (SQRT (* p (- p a) (- p b) (- p c))) )
      ((MINUSP d) NIL)
      ((ZEROP d) (/ (- b) (* 2 a)))
      (LIST (/ (+ (- b) (SQRT d)) (* 2 a)) (/ (- (- b) (SQRT d)) (* 2 a))) )

