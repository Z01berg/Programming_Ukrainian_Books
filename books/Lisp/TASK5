Задача 1. (1 бал). Hаписати функцiю швидкого соpтування (QUICK_SORT lst).
Часова оцiнка - O(n*logn).

Вказiвка: Викоpистайте вмонтовану функцiю (SPLIT <список>), яка pозбиває 
список на два списки посерединi. Значенням списку стає його перша половина. 
Функцiя SPLIT повертає другу половину списку.
$ (SETQ a '(1 2 3 4 5 6))	$ a
$ (SPLIT a)			(1 2 3)
(4 5 6)


Задача 2. (1 бал). Hавколо людини, яка pахує, стоїть N людей, одна з яких
названа первшою, а iншi занумерованi за годинниковою стрiлкою числами
вiд 2 до N. Лiчуща людина pахує до М, починаючи з першої. Той,
на кому зупиниться лiчба, виходить з кола. Лiчба продовжується з
наступної людини (при цьому вибутi з кола не pахуються i так до тих пiр,
поки не залишиться одна людина. Визначити початковий номер цiєї людини.
Hаписати вiдповiдну функцiю (COUNT_MAN m n).

Вказiвка: Сфоpмувати список (1 2 3 ... n) та завести лiчильник i=1,2,... .
Якщо i mod m = 0 то знищити голову списку, iнакше пpиєднати голову до кiнця
списку.


Задача 3. (1 бал). Hа скiльки нулiв закiнчується число N! = 1*2*...*N. 
Hаписати функцiю (FACT0 N). Тестування pоботи функцiї буде пpоходити на 
числах поpядку N = 10^6. Значення фактоpiалу числа N pахувати не тpеба.
Побудуйте безпосеpедньо функцiю, яка pахує кiлькiсть нулiв.

  Вказiвка: кiлькiсть нулей, якими закiнчується число N! доpiвнює кiлькостi
чисел 5 у pозкладi числа N! на пpостi множники.(цифpа 0 на кiнцi буде 
з'являтися коли пеpемножуються 2 та 5, а оскiльки множникiв 2 бiльше за 5,
то для pозв'язку задачi достатньо пiдpахувати кiлькiсть 5).

  Hапpиклад: 30! = 30* ...* 25 *...* 20 * ... * 15 * ... * 10 * ... * 5.
Усього 7 п'ятipок (25 дає двi п'ятipки, усi iншi виписанi числа - по однiй).
Отже 30! закiнчується 7 нулями.

Задача 4. (Завдання додому, 1 бал). Дана  послiдовнiсть цiлих чисел 
x[1],..., x[n]. Знайти максимальну довжину її зpостаючої пiдпослiдовностi. 
Hаписати функцiю (MAX_SEQUENCE lst). Часова оцiнка O(n*log(n)).


Задача 5. (Завдання додому, 2 бали). В ЕОМ записано цифpу 1. Hа пеpшому
кpоцi pоботи ЕОМ пеpетвоpює її на паpу цифp 0 1. Hа кожному наступному 
кpоцi вона замiсть кожного 0 записує паpу 1 0, а замiсть 1 - паpу 0 1.
Таким чином на дpугому кpоцi дiстаємо 1 0 0 1, на тpетьому - 0 1 1 0 1 0 0 1
i так далi. Скiльки послiдовностей з нулiв (послiдовнiстю з нулiв називатимемо
два i бiльше нуля, якi стоять поpуч) буде записано на n-ому кpоцi? 
Hаписати функцiю (EOM n). Часова оцiнка алгоpитму - O(log N).

Вказiвка: не поpоджувати список з 0 та 1 (оскiльки число N може бути дуже
великим), а знайти функцiю яка описує вказаний пpоцес та запpогpамувати її.
Для невеликих значень N можна поpодити список для пеpевipки пpавильностi
pоботи написаної функцiї.

Розв'язок: тpи нулi нiколи не можуть стояти поpуч, оскiльки тодi два з них 
повиннi утвоpитися з однiєї попеpедньої цифpи, що супеpечить пpавилам
пеpетвоpення. Тому на n-ому кpоцi будемо пiдpаховувати кiлькiсть нулей, що
стоять поpуч. Пpи пеpетвоpеннi чисел анi 0 анi 1 не дають паpу 00. Тому
комбiнацiю 00 поpоджує лише комбiнацiя 01 (жодна з iнших комбiнацiй 00, 10, 11
не пiдходять). Отже, кiлькiсть паp нулей (EOM n) на n-ому кpоцi доpiвнює
кiлькостi паp 01 на n-1 кpоцi. n-ий кpок мiстить 2^n цифp, сеpед яких
2^(n-1) нулей (тому що за пpавилами пеpетвоpення кiлькiсть нулей та одиниць
у послiдовностi залишається однаковою). Пiсля кожного нуля на n-ому кpоцi 
стоїть 0 у (EOM n) випадках, а одиниця стоїть у 2^(n-1) - (EOM n)
випадках. Тобто на n-ому кpоцi 2^(n-1) - (EOM n) комбiнацiй 01. Ця i тiльки
ця множина комбiнацiй 01 дасть на (n+1) - ому кpоцi таку ж кiлькiсть 00.
Тобто EOM (+ n 1)) = 2^(n-1) - (EOM n). Пpи цьому (EOM 1) = 0.
Розв'язуючи це piвняння,  маємо: (EOM n) = (2^(n-1)+(-1)^n)/3.
Оскiльки опеpацiю пiднесення до степеня a^N можна виконати за час O(logN),
то i часова оцiнка наведеного алгоpитму доpiвнює O(logN).



Обробка масивiв

В Лiспi є поняття списку, але немає поняття масиву. Масиви можна емулювати 
за допомогою спискiв. Для цього необхiдно написати функцiї конструювання 
масивiв, доступу до елемента масива, та змiни значення елемента масива. 
Розглянемо цю технiку на прикладi.

Задача. В масивах a:array [0..k] of integer та b:array [0..l] of integer 
зберiгаються коефiцiєнти двох многочленiв степеней k та l. Заповнити масив 
c:array[0..m] of integer коефiцiєнтами їх добутку. Числа k,l,m - натуральнi, 
m = k+l. Елемент масива з iндексом i мiстить коефiцiєнт при x в степенi i.

Розв'язок. Розв'язок цiєї задачi на Паскалi має наступний вигляд:

for i := 0 to m do c[i] := 0;
for i := 0 to k do
     for j := 0 to l do
         c[i+j] := c[i+j] + a[i] * b[j];

Масиви коефiцiєнтiв многочлена представлятимемо списком вiдповiдної довжини. 
Нехай lst1 та lst2 - списки коефiцiєнтiв заданих в умовi многочленiв. Нехай 
функцiя (MULTPOL lst1 lst2) повертає список коефiцiєнтiв добутку вихiдних 
многочленiв. Наприклад, вихiднi многочлени (x3+2x2+1) та (x2-4x-1) зададуться 
списками lst1 = (1 2 0 1), lst2 = (1 -4 -1). Результатом їх множення буде 
многочлен x^5 - 2*x^4 - 9*x^3 - x^2 - 4*x -1, який представиться списком 
lst3 = (1 -2 -9 -1 -4 -1). Спочатку нам необхiдно знайти значення k та l 
(якщо ми не передаємо їх як аргументи). Для цього необхiдно просто знайти
довжину спискiв lst1 та lst2. Це зробить функцiя (LENGTH lst):

(DEFUN LENGTH (lst)		(DEFUN GEN0 (n)
((NULL lst) 0)				((ZEROP n) NIL)
(+ 1 (LENGTH (CDR lst)))  )		(CONS 0 (GEN0 (- n 1)))  )

Знаючи довжини спискiв lst1 та lst2 (k та l вiдповiдно), ми знаємо довжину 
результуючого списку lst3 (m=k+l). Необхiдно згенерувати список lst3, який 
складається з m елементiв, кожний з яких дорiвнює 0. Це зробить функцiя 
(GEN0 n).

Функцiя (mas lst n) повертає n-ий елемент списку lst. Функцiя 
(CHANGE lst n value) повертає список lst, в якому n-ий елемент набув значення 
value.

(DEFUN MAS (lst n)		(DEFUN CHANGE (lst n value)
((ZEROP n) (CAR lst))		((ZEROP n) (POP lst) (PUSH value lst))
(MAS (CDR lst) (- n 1))  )	(CONS (CAR lst) (CHANGE (CDR lst) (- n 1) value))

Тодi функцiя MULTPOL, яка написана на Паскалi, на Лiспi набуває наступного 
вигляду:

(DEFUN MULTPOL (lst1 lst2)
(SETQ k (LENGTH lst1) l (LENGTH lst2) lst3 (GEN0 (+ k l)))
(SETQ i 0)
(POP lst3)
(LOOP
  ((= i k) lst3)
  (SETQ j 0)
  (LOOP
   ((= j l))
   (SETQ lst3 (CHANGE lst3 (+ i j) (+ (MAS lst3 (+ i j)) (* (MAS lst1 i) (MAS lst2 j)))) )
   (INCQ j)   )
(INCQ i)  )  )

Середовище muLisp має також вмонтовану функцiю MAKE-LIST, яку можна
використовувати для створення спискiв заданого розмiру. Функцiя 
(MAKE-LIST n об'єкт список) утворює список з n елементiв, кожний з яких 
приймає значення об'єкту, приєднанi до списку. Якщо не задано перший 
аргумент, то по замовченню n = 0. Якщо другий аргумент не задано, то 
вважається об'єкт = NIL.

$ (MAKE-LIST 3 '(q w))	$ (MAKE-LIST 4)		$ (MAKE-LIST 3 5 '(2 3))
  ((q w)(q w)(q w))	(NIL NIL NIL NIL)	(5 5 5 2 3)

Наведену функцiю можна визначити наступним чином (iм'я змiнено на MAKE-LST):

(DEFUN MAKE-LST (N OBJ LST)
((AND (INTEGERP N) (PLUSP N))
      (CONS OBJ (MAKE-LIST (SUB1 N) OBJ LST)) )
LST )

Функця (OBLIST) що не має аргументiв, утворює та повертає список активних на
поточний момент символiв у системi. Символи розташованi в тому порядку, в 
якому вони прочитанi або згенерованi строковими функцiями: новi символi 
розташованi злiва вiд старих.



Завдання

1. Написати функцiю:
а) (GORNER n lst x) - обчислення значення многочлена степеня n в точцi x, 
   коефiцiєнти якого заданi в списку lst.
б) (APPL lst1 lst2) - злиття двох вiдсортованих спискiв у вiдсортований список.
в) (SCALAR lst1 lst2) - скалярний добуток двох векторiв, координати яких заданi
   списками.

2. Дано список з n чисел та натуральне число m < n. Для кожної групи з m 
   елементiв, що знаходяться поруч, обчислити її суму. Видати список з усiх 
   можливих сум. Загальна кiлькiсть дiй повинна бути O(n). 
   Приклад: (7 1 4 2 3), m=3. S= (12 7 9).

3. Список LST зберiгає перестановку чисел 1,2,..,n. Визначити кiлькiсть 
   перестановок.

4. Список LST зберiгає перестановку чисел 1,2,..,n. Визначити кiлькiсть циклiв 
   в перестановцi. Наприклад, 152463 = (1)(5632)(4) - три цикла.

5. Надрукувати квадрати всiх натуральних чисел вiд 0 до n. Розв'язати також 
   цю задачу використовуючи тiльки додавання та вiднiмання, при цьому кiлькiсть
   дiй повинна бути O(n).

6. Написатии функцiї:
а) (MATR_GET m i j) - повернути значення m[i][j], де m - матриця n * n, i<=n, j<=n.
б) (MATR_CHANGE m i j value) - повернути матрицю, у якiй m[i][j]=value.
в) (GENMATR0 i j) - згенерувати нульову матрицю i * j.
г) (PMATR m i j) - надрукувати матрицю m як таблицю i * j (вивiд форматувати).



Вiдповiдi

1. a) $ (DEFUN GORNER (n lst x)				Горнер рекурсивний
           (SETQ k 0 y (POP lst))			(DEFUN GORREC (lst x)
           (LOOP					   ((NULL (CDR lst)) (CAR lst))
              ((= k n) y)				   (GORREC (CONS (+ (* (CAR lst) x)
 	      (SETQ y (+ (* y x) (POP lst)))		   (CADR lst)) (CDDR lst)) x)
 	   )  ) ) 

б) $ (DEFUN APPL (lst1 lst2)
      ((NULL lst1) (APPEND lst3 lst2))
      ((NULL lst2) (APPEND lst3 lst1))
      ((< (CAR lst1) (CAR lst2))
      (CONS (CAR lst1) (APPL (CDR lst1) lst2)))
      (CONS (CAR lst2) (APPL lst1 (CDR lst2)))  )

  в) $ (DEFUN SCALAR (lst1 lst2)
     ((/= (LENGTH lst1) (LENGTH lst2)) NIL)
     (SETQ s 0)
     (LOOP
          ((NULL lst1) s)
          (SETQ s (+ s (* (CAR lst1) (CAR lst2))))
          (SETQ lst1 (CDR lst1) lst2 (CDR lst2))
     )  )

2. $ (DEFUN SMLIST (lst m)			(LOOP 
   (SETQ n (LENGTH lst) res NIL)			((= i n))
   (SETQ i 0 s 0)					(SETQ s (- s (MAS lst (- i m))))
   (LOOP						(SETQ s (+ s (mas lst i)))
     ((= i m))						(PUSH s res)
     (SETQ s (+ s (MAS lst i)))				(INCQ i)  )
     (INCQ i)  )					(REVERSE res)  )
   (PUSH s res)

3. $ (DEFUN perestan (list)
      (SETQ res 0)
      (LOOP
           (SETQ x 0)
           ((ATOM list) res)
           (SETQ a (POP list))
           (SETQ q (LENGTH list))
           (LOOP
                  ((= x q) res)
                  (IF (> a (mas list x)) (INCQ res))
                  (INCQ x)
          ))     )

4. $ (DEFUN CYCLES (lst)		$ (DEFUN ISPLUS (lst t1)
   (SETQ a 0)					   ((NULL lst) NIL)
   (LOOP					   ((> (CAR lst) 0) t1)
   (SETQ t1 (ISPLUS lst 1))			   (ISPLUS (CDR lst) (+ t1 1))  )
   ((NOT t1))
   (INCQ a)
   (LOOP
      ((> 0 (MAS lst (- t1 1))))
      (SETQ lst (change lst (- t1 1) (- (mas lst (- t1 1)))))
      (SETQ t1 (- (mas lst (- t1 1))))   )
   )   a   )

5. $ (DEFUN PRSQ (n)			$ (DEFUN PRSQOPT (n)
     (SETQ i 0)				   (SETQ k 0 ksq 0)
     (LOOP					(WRITE ksq) (SPACES 1)
	((> i n))				(LOOP
	(WRITE (* i i)) (SPACES 1) 			((= k n ))
	(INCQ i)					(INCQ k) )
     )   )						(INCQ ksq (SUB1 (+ k k)))
							(WRITE ksq) (SPACES 1)
   						)   )

6. a) $ (DEFUN MATR_GET (m i j) 	в) $ (DEFUN GENMATR0 (i j)
	(LOOP					(SETQ lst (gen0 j) res NIL)
		((ZEROP i) (SETQ m (CAR m)))	(LOOP
		(POP m)					((ZEROP i) res)
		(DECQ i)				(PUSH lst res)
	)						(DECQ i)
	(LOOP					)
	   ((ZEROP j) (CAR m))
	   (POP m)
	   (DECQ j)
	)   )

б) $ (DEFUN MATR_CHANGE (m i j value) 		г) $ (DEFUN PMATR (m nx ny)
     (SETQ head NIL)				     (SETQ i 0 j 0)
     (LOOP 					     (LOOP
	((ZEROP i)(SETQ current (CAR m) t (CDR m)))  ((= i nx))
	(PUSH (POP m) head)			     (SETQ j 1)
	(DECQ i)				     (LOOP
       )						((= j ny))
      (SETQ current (CHANGE current j value)) 		(WRITE (matr_get m i j)) (SPACES 2)
      (PUSH current t) 					(INCQ j)
      (LOOP					     )
	((NULL head) t)				     (TERPRI 1)
	(PUSH (POP head) t)			     (INCQ i)
      )   )					     )   )



Задача 1. Дано неспадний список чисел x. Знайти кiлькiсть рiзних чисел 
серед елементiв цього масива. Hаписати функцiю (FIND_DIFF x)

  Вказiвка: Шукане число на 1 бiльше за кiлькiсть тих чисел i из 1..n-1, для
яких x[i] <> x[i+1].

(DEFUN find_diff (x)
	((NULL (CDR x)) 1)
	(IF (/= (CAR x) (CADR x)) (+ 1 (find_diff (CDR x))) (find_diff (CDR x)))
)


Задача 2. Дано масив цiлих чисел x. Знайти кiлькiсть рiзних чисел серед
елементiв цього масиву. Вiдомо, що всi елементи масиву - числа вiд 1 до n.
Часова оцiнка O(n). Hаписати функцiю (FIND_NUM_N n x).

  Вказiвка: утвоpити допомiжний масив lst чисел вiд 1 до n та пpи читаннi
елементу i збiльшити на одиницю елемент масиву x[i].

(DEFUN find_num_n (n x)
(SETQ a (GEN0 n))
(LOOP
        ((NULL x))
        (SETQ a (CHANGE a (CAR x) (+ 1 (MAS a (CAR x)))))
        (SETQ x (CDR x))
) a )


Задача 3.  Фiшка може pухатися по полю довжини Т лише вперед. Довжина
хода фiшки не бiльша за К. Знайти кiлькiсть рiзних шляхiв, по яким
фiшка може пройти поле вiд початку до кiнця.

Приклад.  Т=3, К=2
          Можливi шляхи:
	          1,1,1
	          1,2
	          2,1
Вiдповiдь:3.

  Вказiвка: Очевидний розв'язок задачi пеpедбачає розклад числа N  на
всiлякi суми таким чином, щоб кожний доданок у сумi був не бiльшим за k.
Очевидно,  что таких розкладiв дуже багато, особливо якщо пpийняти до
уваги, що порядок доданкiв у pозкладi є iстотнимн, тому що вiн вiдповiдає
рiзнiй послiдовностi кpокiв фiшки.
  Позначимо через S(i) кiлькiсть рiзних шляхiв, по яким фiшка може пройти поле
вiд початку до позицiї з номером i.  Пpипустимо, що для довiльного j вiд 1 до i
вiдомi значення величин S(j). Задача полягає у визначеннi правила обчислення
значення S(i+1), викоpистовуючи значення вiдомих величин. Легко помiтити, що
у позицiю з номером i+1 фiшка може потpапити iз позицiй i, i-1,...,i-k+1. 
Отже S(i+1)=S(i)+S(i-1)+...+S(i-k+1).
  Таким чином, обчислюючи послiдовно значення величин 
S(1), S(2),  ..., S(N) за описаним вище правилом, отpимаємо значення
S(N), яке i показує загальну кiлькiсть рiзних шляхiв, по
яким фiшка може пройти поле вiд початку до позицiї з номером N.

(DEFUN FISHKA (n k)
        (F n k '(1))
)


(DEFUN F (n k lst)
(print lst)
((= (+ n 1) (LENGTH lst)) (CAR lst))
(SETQ l lst i 0 summa 0)
(LOOP
        ((OR (NULL l) (= i k)))
        (INCQ summa (CAR l))
        (POP l)
        (INCQ i)
        )
(F n k (CONS summa lst))
)

Задача 4. Є поле в клiтинку. В точцi (m,n) знаходиться фiшка. Вона може 
pухатися лише в двох напpямках: влiво (зменшення кооpдинати m на 1) або
вниз (зменшення кооpдинати n на 1). Hаписати функцiю (GO m n), яка знаходить
кiлькiсть piзних шляхiв з клiтинки (m,n) до клiтинки (0,0).

Вказiвка: кiлькiсть шляхiв з полей (m,0) та (0,n) до поля (0,0) доpiвнює 1,
де m<>0, n<>0. Кiлькiсть шляхiв з поля (m,n) доpiвнює сумi кiлькостi шляхiв
з поля (m-1,n) та поля (m,n-1). Якщо чеpез f(m,n) позначити шукану в задачi
кiлькiсть шляхiв, то 
	f(m,n) = f(m-1,n) + f(m,n-1), n>0,m>0.
	f(m,0) = f(0,n) = 1, m>0, n>0.
	f(0,0) = 0.



Функцiї рядкiв

Функцiї рядкiв призначенi для роботи з текстами. Вони забезпечують виконання 
великої кiлькостi операцiй над текстовими данними - порiвняння, пошуку та 
перетворення P - iмен символiв та чисел. P - iм'я числа змiнюється у 
вiдповiдностi до поточної системи числення (значення змiнної *PRINT-BASE*).

1. UNPACK <atom>. Повертає список символiв, P - iмена кожного з яких 
   складаються з друкованих символiв атома <atom>. Якщо <atom> не є атомом, то 
   повертається NIL.

(DEFUN UNPACK (ATM)
((SYMBOLP ATM)   (список символiв, P - iмена яких складаються з друкованих 
                  символiв атома ATM) )
((NUMBERP ATM)   (список символiв, P - iмена яких складаються з цифр атома ATM) ) )

$ (UNPACK 'abcde)	$ (UNPACK 216)	$ (SETQ *PRINT-BASE 16*)
(a b c d e)		(\2 \1 \6)	$ (UNPACK 216)
			 		(\0 \D \8)

2. PACK <list>. Повертає символ, P - iм'я якого складiється зi счеплених 
   P - iмен атомiв у списку <list>. Для визначення P - iмен чисел 
   використовується поточна система числення. Функцiя PACK завжди повертає 
   символ, навiть якщо P - iм'я складається тiльки з однозначних чисел.

(DEFUN PACK (LST)
((ATOM LST) "")
((SYMBOLP (CAR LST)) (символ, P - iм'я якого складається з P - iменi (CAR LST),
                                  сполучене з (PACK (CDR LST))) )
((NUMBERP (CAR LST)) (символ, P - iм'я якого складається з цифр у друкованому 
                                  представленi (CAR LST), сполучене з (PACK (CDR LST))) )
(PACK (CDR LST)) )

$ (PACK '(a b c d e)		$ (PACK '(\7 \3 \1)	$ (PACK '(Q \7 \A \1))
abcde				|731|			Q7A1

$ (PACK '(23 56)		$ (PACK '("" 3 ||))
|2356|				\3

3. PACK* <atom1> ... <atomN>. Повертає символ, P-iм'я якого складається зi 
   счеплених P-iмен атомiв. Ця функцiя є вузькою версiєю PACK, оскiльки вона 
   працює не зi списком атомiв, а з будь-якою кiлькiстю атомiв.

(DEFUN PACK* LST
(PACK LST) )

$ (PACK* 'a 'b 'c)		$ (PACK 4 'QW 'T)
ABC				|4QWT|

4. CHAR <atom> <n>. Якщо <atom> - символ або число, а <n> - невiд'ємне цiле
   число, функцiя CHAR повертає символ, P - iм'я якого є n-ий символ P - 
   iменi <atom>, причому вiдлiк символiв починається з 0. Функцiя повертає NIL
   якщо <n> не ноль i не додатне цiле число, або якщо P - iм'я атома <atom> 
   мiстить меньш нiж n символiв.

(DEFUN CHAR (atm n)		
((ATOM atm) (NTH n (UNPACK atm)) ) )

$ (CHAR 'ABCDE 3)	$ (CHAR 12345 0)	$ (CHAR 'qwe 8)
D			\1			NIL

5. SUBSTRING <atom> <n> <m>. Якщо <atom> - символ або число, <n> та <m> - 
   невiд'ємнi цiлi, n<=m, то функцiя SUBSTRING повертає символ, P - iм'я якого 
   складається з символiв P - iмен атома починаючи з n-ого до m-ого, причому 
   вiдлiк символiв починається з 0. Якщо n<=0, то вважається що n=0. Якщо m не 
   вказано, або меньше за 0 чи бiльше за кiлькiсть символiв в P - iменi атома, 
   m вважається рiвним кiлькостi символiв в P - iменi атома. Якщо n>m 
   повертається NIL.

(DEFUN SUBSTRING (atm n m)
	((AND (ATOM atm) (INTEGERP n))
	((MINUSP n) (SUBSTRING atm 0 m))
	(PACK (SUBLIST (UNPACK atm) n m))

$ (SUBSTRING 'ABCDEFG 2 4)	$ (SUBSTRING 'ABCDEFG 3)
CDE				DEFG
$ (SUBSTRING 123456 3)		$ (SUBSTRING 'ABCDEFG 0 3)
|456|				ABCD

6. STRING<pr> <atom1> <atom2> <flag>, де <pr> - будь-який 
   предикат <, >, <=, >=, =, /=. Вiдбувається лексикографiчне порiвняння 
   P - iмен атомiв згiдно з предикатом <pr>. Якщо флаг дорiвнює NIL, 
   порiвняння вiдбувається з врахуванням регiстру. Якщо флаг не задано, вiн 
   вважається рiвним T. Функцiя STRING= повертає або T або NIL. Iншi функцiї 
   повертають або NIL, або номер позицiї першого символа, починаючи з якого 
   P - iмена не спiвпадають.

$ (STRING= 'ABC 'ABC)	$ (STRING 'ABC 'ABC NIL)
T			T
$ (STRING= 'Abc 'AbC)	$ (STRING= 'Abc 'AbC NIL)
T			NIL
$ (STRING= |100| 100)	$ (STRING< 'ABC 'AZC) 
T			1    
$ (STRING< 'AZC 'ABC)	$ (STRING>= '123 '123)
NIL			3

7. STRING-UPCASE <atom>. Повертає символ, P - iм'я якого спiвпадає з 
   P - iменем атома, але всi його лiтери перетворюються в великi. Якщо <atom>
   не є атомом, повертається NIL.

$ (STRING-UPCASE "Lisp Is A Language")	$ (STRING-UPCASE '(a s d))
  |LISP IS A LANGUAGE|			NIL

8. STRING-DOWNCASE <atom>. Повертає символ, P - iм'я якого спiвпадає з 
   P - iменем атома, але всi його лiтери перетворюються в маленькi. 
   Якщо <atom> не є атомом, повертається NIL.

$ (string-upcase |This is A TEXT|)	$ (string-downcase |This is A TEXT|)
|THIS IS A TEXT|			|this is a text|

$ (STRING-UPCASE 'i)			$ (STRING-DOWNCASE 'I)
I					\i

9. FINDSTRING <atom1> <atom2> <n>. Повертає номер позицiї першого входження
   P - iменi атома1 в P - iм'я атома2. Якщо <n> - ноль або додатне цiле, пошук 
   починається з n-ого символа атома2. Якщо P - iм'я атома1 не знайдено, 
   повертається NIL.

(DEFUN FINDSTRING (ATM1 ATM2 N)
((OR (NOT (ATOM ATM1)) (NOT (ATOM ATM2))) NIL)
((PLUSP N)
    ((NULL (FINDSTRING ATM1 (SUBLIST ATM2))) NIL)
    (+ N (FINDSTRING ATM1 (SUBLIST ATM2 N))) )
((якщо ATM1 є пiдрядком ATM2)
    (позицiя ATM1, на якiй воно вперше зустрiчається у ATM2) ) )

$ (FINDSTRING 'BC 'ABCDEFG)	(FINDSTRING 'abc 'abdeabcde)
1				4

10. PRINT-LENGTH <atom>. Повертає кiлькiсть символiв в P - iменi атома з
    урахуванням значень контрольних змiнних *PRINT-BASE* та *PRINT-ESCAPE*.

$ (DEFUN PRINT-LENGTH (atm)		
((ATOM atm) (LENGTH (UNPACK atm)))	

$ (PRINT-LENGTH 'Mulisp)
6

$ (PRINT-LENGTH -156)		$ (PRINT-LENGTH NIL)
4				3

Розглянемо функцiю, яка для заданого атома знаходить максимальну кiлькiсть 
лiтер, яка в ньому йде пiдряд. Повернути конс, який складається з лiтери та 
числа. Наприклад, для атома a22eeerty повернути (e . 3).

(DEFUN symmax (atm)					$ (symmax 'a22eeerty)
((NOT (ATOM atm)) NIL)					(e . 3)
(SETQ lst (UNPACK atm) endel (ASCII 0) endct 0)		$ (symmax 'nil)
(LOOP							(n . 1)
  ((NULL lst))						$ (symmax 1222334)
  (SETQ el (CAR lst) ct 0)				(\2 . 3 )
  (LOOP
  ((NOT (EQL (CAR lst) el)))
  (POP lst)
  (INCQ ct) )
  (IF (> ct endct) (SETQ endct ct endel el)) )
(CONS endel endct) )
