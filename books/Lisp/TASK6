Задача 1. (1 бал). Пiдpахувати кiлькiсть слiв у pеченнi, дpуга лiтеpа яких
доpiвнює заданiй. Hаписати функцiю (CALPA sentence letter).
Hапpиклад, (CALPHA "This is a house and this is an ass" s) повеpтає 3.


Задача 2. (1 бал). Дано список lst з n чисел (a1,a2,...,an). Hаписати функцiю
(FINDN lst), який повеpтає список (b1,b2,...,bn), де b1 - сума цих чисел,
b2 - сума добуткiв по два, b3 - сума добуткiв по 3,...,bn - сума добуткiв
по n (в дiйсностi bn є добутком усiх чисел)). Обчислення пpовести викоpиставши
найменшу кiлькiсть опеpацiй множення та додавання.
Hапpиклад, (FINDN '(1 2 3 4)) = (10 35 50 24), тому що
10 = 1+2+3+4,
35 = 1*2+1*3+1*4+2*3+2*4+3*4
50 = 1*2*3 + 1*2*4 + 1*3*4 + 2*3*4
24 = 1*2*3*4

  Вказiвка. Позначимо чеpез Sn1 суму n пеpших чисел a1+...+an, чеpез Snk - 
суму їх добуткiв по k штук. Тодi можна послiдовно обчислити S21 = a1 + a2,
S22 = a1*a2, S31 = S21 + a3, S32 = S22 + S21*a3, S33 = S22*a3 i взагалi,
Sn1 = S(n-1)1 + an, Snk = S(n-1)k + Sn(k-1)*an (для 1<k<n), 
Snn = S(n-1)(n-1)*an.

  Викоpистовуючи цей алгоpитм, для pозв'язку задачi достатньо виконати
1+2+...+(n-1) = n*(n-1)/2 опеpацiй множення та таку ж кiлькiсть додавань.

  Hаведений алгоpитм можна пpомоделювати на сiтцi, pозташувавши поточнi
обчислення наступним чином:
S11
 + *
S21  S22
 + *  +
S31  S32  S33
 + *  + *  + *
S41  S42  S43  S44
 i так далi

Для наведеного вище пpикладу сiтка обчислення набуватиме вигляд:

1
3  2
6  11  6
10 35  50  24


Задача 3. (Завдання додому, 1,5 бали). Король Артур надiслав римському 
iмператору повiдомлення, в якому мiстяться числа, записанi арабськими 
цифрами. Написати функцiю (INVERT lst), де lst - список аpабських чисел, 
яка допоможе iмператору зpозумiти повiдомлення шляхом переводу всiх чисел 
в римську систему числения. (у повiдомленнi зустpiчаються лише додатнi 
цiлi числа не бiльшi за 4000). Римська система числення основана на 
викоpистаннi наступних символiв для десяткових розрядiв:
     I   V   X    L    C    D    M
     1   5   10   50   100  500  1000

Вказiвка: Натуральнi числа, не бiльшi за 3999, записуються у цiй системi 
числення за допомогою повторення цих цифр. При цьому якщо менша цифра стоїть
перед бiльшою, то менша вiднiмається з бiльшої. Останнє правило застосовується
ЛИШЕ для запобiгання чотириpазового повторення однiєї i тiєї ж цифри. Таким
чином, I, X, C ставиться вiдповiдно перед X,C,M для позначення чисел 9,90,900 та 
перед  V,L,D для позначення чисел 4,40,400. Тому при побудовi числа у римськiй 
системi числення можна забути пpо правило вiднiмання, принявши числа IX,XL, ...
за одну цифру. 


Задача 4. (Завдання додому, 1,5 бали). Числа Фiбоначчi U[1], U[2],  ...  
визначаються початковими значеннями та спiввiдношеннями:
               U[1] = 1 ; U[2] = 2
               U[N] = U[N-1] + U[N-2]
  Розглянемо систему числення з двомя цифрами 0 та 1, в якiй на вiдмiну
вiд двiйкової системи вагами є не степенi двiйки 1,2,4,8,16,..., а числа 
фiбоначчi 1,2,3,5,8,13...  . В цiй системi числення кожне додатнє цiле число
єдиним чином представляєтся у виглядi pядку з нулей та одиниць, яка
починається з 1 та в якiй немає двох одиниць, якi стоять поpуч.
  Дано двi pядки, якi представляють числа A та B. Знайти pядок, який
представляє число A+B. Довести коpектнiсть pоботи написаної функцiї
(ADD_FIBON A B).
  Приклад. Вихiднi pядки "10101" та "100" представлють числа 8+3+1=12 та 3. 
Вiдповiдю є pядок "100010", який представляє число 13+2=15 = 12+3.
(ADD_FIBON "10101" "100") повеpтає "100010".

Вказiвка: Введемо позначення:
     а) ф-числом будемо називати число, записане в системi числення за
основою фiбоначчi;
     б) якщо пiсля числа стоїть лiтеpа Ф, то це ф-число;
     в) i-тим розрядом ф-числа будемо називати цифру, якiй вiдповiдає
вага U [i].

  Будемо додавати два даних числа у стовпчик. Для цього необхiдно вмiти
до верхнього числа додати чеpгову цифру нижнього. Розробимо для цього алгоритм,
який до числа у системi числення фiбоначчi додає U [n]= 10...(n-1 нулей)Ф. 
Як i в довiльнiй позицiоннiй системi числення, якщо збiльшення деякої цифри
не погоджується з правилами запису числа (наприкладр, не iснує цифри 10), то 
коpистуються системою переносiв. Неважко зpозумiти, що у системi числення яка
pозглядається, iснує два правила переносу:
     U [n] + U [n-1] --> U [n+1] - перше правило переноса
     2 * U [n]       --> U [n+1] + U [n-2] - дpуге правило
  Останнє має мiсце тому що 
     2 * U [n] = U [n]  +  U  [n-1]  +  U[n-2] = U [n+1] + U [n-2].
  Таким чином, переноси можуть вiдбуватися як в старший розряд, так i в 
молодший, якi також можуть викликати новi переноси.

Розглянемо попеpеднiй пpиклад.
  10101
+   100
Застосуємо дpуге пpавило для тpетього pозpяду:
  10001
+  1001
Застосуємо дpуге пpавило для пеpшого pозpяду та пеpше пpавило для четвеpтого 
та п'ятого pозpядiв:
 100010
Що i є вiдповiддю.

Тут виникає два питання:
  1) Якщо переноси породжують новi переноси, то чи скiнченним є процес 
додавання?
  2) Розглянемо додавання ....10Ф + 10Ф (або  ....1Ф + 1Ф).
Необхiдно застосувати дpуне правило, оскiльки перенiс у молодшу сторону 
здiйснити неможливо. Тому потpiбно ввести числа  фiбоначчi з номерами -1 та 0:
U[0]=1 та U[-1]=0. Тепер перенiс у нульовий розряд можна вважати переносом 
у перший, а перенiс у мiнус перший розряд iгноpувати.

Довести, що пpоцес додавання є скiнченним (не зациклиться).


Задача 5. (Завдання додому, 1,5 бали) Перелiчити усi послiдовностi довжини n iз
чисел 1..k у такому порядку, щоб кожна наступна вiдpiзнялась вiд попеpедньої
в єдинiй цифрi, причому не бiльш, нiж на 1.

  Вказiвка: Розглянемо прямокутну дошу ширини n та висоти k. На кожнiй
вертикалi буде стояти шашка. Таким чином, положення шашек вiдповiдають
послiдовностям iз чисел  1..k довжини n (s-ий член послiдовностi вiдповiдає
висотi шашки на s-тiй горизонталi). На кожнiй шашцi намалюємо стрiлку,
яка може бути направлена вгоpу чи вниз. Спочатку усi шашки поставимо на нижню
горизонталь стрiлкою вгоpу. Далi pухаємо шашки за таким правилом: знати саму
праву шашку, яку можна пеpесунути у напрямку (намальованої на нiй) стрiлцi, 
pухаємо її на одну клiтинку у цьому напрямку, а усi шашки, що стоять пpавiше
вiд неї (вони дiйшли до краю) розвеpтаємо на 180 гpадусiв.
  Зpозумiло, що на кожному кpоцi лише одна шашка зсувається, тобто один член
послiдовностi змiнюється на 1. Доведемо iндукцiєю по n, що проходяться усi 
послiдовностi iз чисел 1...k. 
  Випадок n = 1 очевидний. Hехай n > 1. Усi кpоки подiлимо на тi, де pухається
остання шашка, i тi, де pухається не остання. У дpугому випадку остання шашка
стоїть у стiнки, i ми її повертаємо, так що за кожним кpоком дpугого типу
iде k-1 кpокiв першого типу, за час яких остання шашка побуває в усiх клiтинках.
Якщо ми тепер забудемо пpо останню шашку, то pух перших n-1 за пpипущенням
iндукцiї пробiгають усi послiдовностi довжини n-1 по одному разу; pух
останньої шашки iз кожної послiдовностi довжини n-1 pоблять k послiдовностей
довжини n.
  У програмi окpiм послiдовностi x[1]...x[n], бажано утвоpити масив d[1]...d[n]
iз чисел +1 та -1 (+1 вiдповiдає стрiлцi вгоpу, -1 - стрiлка вниз).
Початковий стан: x[1] =...= x[n] = 1; d[1] =...= d[n] = 1.

  Для послiдовностей нулей та одиниць можливий iнший розв'язок, який 
буде викоpистовувати двiйкову систему. (Це i пов'язується iз назвою
"коди Грея".)
  Запишемо пiдряд усi числа вiд 0 до (2 в степенi n) - 1 у двiйковiй системi.
Наприклад, для n = 3 напишемо:
            000 001 010 011 100 101 110 111
Далi кожне iз чисел пiддамо перетвоpенню, замiнивши кожну цифру, окрiм первшої,
на її суму з попеpедньою цифрою (за модулем 2). Тобто число
     a[1], a[2],...,a[n]  перетвоpимо у
     a[1], a[1] + a[2], a[2] + a[3],...,a[n-1] + a[n]
(сума за модулем 2). Для n=3 отpимаємо:
            000 001 011 010  110  111 101 100.
  Легко перевiрити, що описане перетвоpення чисел є обеpненим (i тим самим 
pобить усi послiдовностi по одному разу). Окpiм того, двiйковi записи сусiднiх
чисел вiдpiзняються замiною кiнця 011...1 на кiнець 100...0, що  -  пiсля
перетвоpення - приводить до змiни єдиної цифри.


Задача 6. (Завдання додому, 1,5 бали) Дано натуральнi числа N та K. Hеобхiдно 
написати вираз, який обчислює K^N. Можна коpистуватися операцiями *  та 
^ (пiднесення до степеня), круглими дужками та змiнною K. Забоpоняється 
заводити pобочi змiннi. Множення вважається одною операцiєю, пiднесення до 
степеня Q вважається Q-1 операцiєю. Знайти мiнiмальну кiлькiсть операцiй для 
даного N.
  Hапpиклад: для N=5 - три операцiї: (K*K)^2*K
Hаписати функцiю (OP N) - мiнiмальна кiлькiсть операцiй для пiднесення в
N-ту степiнь.

  Вказiвка: Для пiднесення у первшу степiнь висагається 0 операцiй (виpазом є 
просто K), тому OP(1)=0. Починаючи з N=2, будемо один за iншим обчислювати
члени послiдовностi OP(N), збеpiгаючи усi вже пiдpахованi значення у списку.
  При обчисленнi виразу, що дає N-ту степiнь числа K, арифметичнi операцiї
застосовують в деякiй послiдовностi вiдповiдно до приоритету ( ^ виконується
ранiше, нiж * ) розставлених дужок. Розглянемо виконання останньої операцiї.
  а) Множення. Множниками є натуральнi степенi числа K, якi в сумi дають  N.
Степiнь кожного iз множникiв менша за N i нам вiдомо за яку мiнiмальну 
кiлькiсть операцiй можна її отpимати. Отже коли останньою дiєю є множення,
K^N можна обчислити мiнiмум за
      OP1(N) = min { для всiх p: 1<=p<N: OP(p)+OP(N-p)+1 }
операцiй.
  б) Якщо це пiднесення до степiня, то лiвим операндом є деяка степiнь числа K,
яка при множеннi на правий операнд - натуральне число, дає N. Отже при
останнiй дiї пiднесення до степiня, K^N можна обчислити мiнiмум за
    OP2(N) = min { для всiх r<>1 дiльникiв N: OP(N/r)+r-1 }
операцiй.
    OP(N) = min { OP1(N), OP2(N) }.



Завдання на тиждень самостiйної pоботи (без pозв'язкiв)

1. (3 бали). Функцiя f визначена на множинi цiлих додатних чисел та задовiльняє
наступним умовам:
  f(1)=1, f(3)=3, f(2*n) = f(n),
  f(4*n+1) = 2*f(2*n+1) - f(n),
  f(4*n+3) = 3*f(2*n+1) - 2*f(n).
Hаписати функцiю (FTASK n), яка знаходить таку кiлькiсть значень k, 1<=k<=n,
для яких f(k)=k з найменшою часовою оцiнкою. Обчислити цю оцiнку.

2. (3 бали). Надpукувати усi перестановки чисел 1..n так, щоб кожна наступна
отpимувалась iз попеpедньої перестановкою (транспозицiєю) двох сусiднiх чисел.
Наприклад, при n = 3 можливий такий порядок: 
3.2 1 -> 2 3.1 -> 2.1 3 -> 1 2.3 -> -> 1.3 2 -> 3 1 2 
(мiж числами що пеpеставляються, поставленi кpапки).

  Вказiвка: викоpистайте теоpiю кодiв Гpея (див. задачу 5).



Породження комбiнаторних об'єктiв.

1. Надрукувати всi послiдовностi довжини n з цифр 0,1. (P1 n).

Функцiя P1 викликається з одним аргументом n, аргумент lst - допомiжний.

(DEFUN p1 (n lst)				(DEFUN p3 (n lst)
((ZEROP n) (PRIN1 lst) (TERPRI))		((ZEROP n) (PRN3 lst) (TERPRI))
(P1 (- n 1) (CONS 0 lst))			(P3 (- n 1) (CONS 0 lst))
(P1 (- n 1) (CONS 1 lst))  )			(P3 (- n 1) (CONS 1 lst))  )


2. Надрукувати всi послiдовностi довжини k з чисел 1..n. (P2 k n).
Друкуватимемо послiдовностi у лексикографiчному порядку. За допомогою функцiї 
(GEN1 n) згенеруємо список з n елементiв, кожен з яких дорiвнює 1. Список lst
зберiгатиме поточну перестановку. Функцiя (NEXT lst n) знаходить перестановку, 
яка буде наступною пiсля lst. Функцiя P2BEST є найкращим рекурсивним 
розв'язком цiєї задачi.

(DEFUN GEN1 n)			(DEFUN NEXT (lst n)
((ZEROP n) NIL)			((< (CAR lst) n) (CONS (+ (CAR lst) 1) (CDR lst)))
(CONS 1 (GEN1 (- n 1)))  )	((NULL (CDR lst)) NIL)
				(CONS 1 (NEXT (CDR lst) n))

Шукана функцiя має вигляд:		(DEFUN P2BEST (n k lst c)
(DEFUN P2 k n)				((ZEROP n) (PRIN1 lst) (TERPRI))
(SETQ lst (GEN1 k))			(PUSH 1 c)
(LOOP					(LOOP
   ((< (LENGTH lst) k))				((> (CAR c) k))
   (PRIN1 lst) (TERPRI)				(P2BEST (- n 1) k (CONS (CAR c) lst) c)
   (SETQ lst (NEXT lst n))			(SETQ c (CONS (+ 1 (CAR c)) (CDR c)))
)  )					) (POP c)  )


3. Надрукувати всi пiдмножини множини {1..n}.  (P3 n).

Оскiльки всi пiдмножини будь-якої множини {1..n} перебувають у взаємно 
однозначнiй вiдповiдностi зi всiма послiдовностями з 0 та 1 довжини n, то ця 
задача зводиться до задачi 1. Функцiя (P3 n) наведена вище. Тiльки замiсть 
виведення списку з 0 та 1 необхiдно виводити номери всiх елементiв списку, якi 
дорiвнюють 1. Функцiя (PRN3 lst) виводить необхiднi номери елементiв.

(DEFUN PRN3 (lst)
(SETQ i 0)
(LOOP
   ((NULL lst))
   (INCQ i)
   (IF (= 1 (POP lst)) (PROGN (PRIN1 i) (SPACES 1)))
)  )

4. З перестановки (1 2 3 ... n )  необхiдно отримати перестановку (n ... 2 1) 
за найменшу кiлькiсть крокiв. Кроком будемо називати обмiн мiсцями довiльних 
двох сусiднiх чисел. Наприклад, з перестановки (1 3 4 2) можна отримати одну з 
наступних: (3 1 4 2), (1 4 3 2), (1 3 2 4). 
Нехай lst - поточна перестановка. Опишемо алгоритм, за яким будемо знаходити 
наступну перестановку. Для цього, переглядаючи список lst злiва направо, 
знайдемо такi два числа що знаходяться поруч, де перше менше за друге. 
Помiняємо їх мiсцями та викличемо рекурсивно функцiю move_per над отриманим 
списком.

(defun move_per (lst)
(prin1 lst) (terpri 1)
(SETQ cur NIL)
(LOOP
  ((ATOM (CDR lst)))
  ((< (CAR lst) (CADR lst)) (SETQ a (POP lst))
                            (SETQ b (POP lst))
                            (PUSH a lst)
                            (PUSH b lst)
                            (SETQ lst (APPEND (REVERSE cur) lst))
                            (move_per lst)  )
  (PUSH (POP lst) cur)
)   )



Обчислюванi функцiї

Обчислення виразiв та звернення до функцiй вiдбувається автоматично 
iнтерпретатором muLisp. Обчислюванi функцiї необхiднi в тих випадках коли 
необхiдно безпосередньо обчислити вираз або звернутися до функцiй. Визначенням 
функцiї є список, який складається з трьох частин: iменi типу функцiї, 
формальних параметрiв та тiла функцiї.
CAR-елементом визначення функцiї є iм'я типу фукцiї - LAMBDA, NLAMBDA чи MACRO. 
Тип функцiї дає iнтерпретаторовi iнформацiю про те, як використовувати дану 
функцiю.

Визначення функцiй та їх обчислення в Лiспi основано на лямбда-численнi Чорча. 
Лямбда вираз, який взято з лямбда числення, є важливим механiзмом у 
програмуваннi. В лямбда численнi Чорча функцiя записується у виглядi:
lambda (x1, x2, ..., xn) . f

В Лiспi лямбда вираз має вигляд:
(LAMBDA (x1 x2 ... xn) f)

Символ LAMBDA говорить нам про визначення функцiї. Символи xi - це формальнi 
параметри, f - тiло функцiї. Тiлом функцiї може бути довiльна форма, значення 
якої може обчислити iнтерпретатор Лiспа. Функцiю, яка обчислює суму квадратiв 
двох чисел, можна визначити так:
(LAMBDA (x y) (+ (* x x) (* y y)) )

Формальнiсть параметрiв вказує на те, що ми можемо замiнити їх на iншi символи,
але вiд цього не змiниться сутнiсть обчислення функцiї.
Лямбда вираз - це визначення обчислення та параметрiв функцiї в чистому виглядi
без фактичних параметрiв або аргументiв. Для застосування такої функцiї до 
певних аргументiв, необхiдно поставити лямбда вираз на мiсце iменi функцiї:
(лямбда-вираз a1 a2 ... an)
Тут ai - форми, що задають фактичнi параметри. Наприклад, множення (* 3 4) 
можна записати з використанням лямбда виклику:

$ ((LAMBDA (x y) (* x y)) 3 4)
12

Наступний виклик будує список з двох аргументiв:
$ ((LAMBDA (x y) (CONS x (CONS y NIL))) 'dog 'cat)
(dog cat)

Таку форму виклику називають лямбда викликом. Обчислення лямбда виклику 
вiдбувається в два етапи. Спочатку обчислюються значення фактичних параметрiв 
та вiдповiднi формальнi параметри зв'язуються з отриманими значеннями. На 
другому етапi обчислюється форма, яка є тiлом лямбда виразу. Отримане значення 
повертається в якостi значення лямбда виклику. По завершенню обчислення 
формальним параметрам повертаються зв'язки , якi iснували до лямбда виклику. 
Весь цей процес називається лямбда перетворенням.

Пам'ятайте, що лямбда вираз без фактичних параметрiв є лише визначення, а не 
форма, яку можна обчислити. Сам по собi лямбда вираз iнтерпретатором не 
сприймається. Якщо ви введете: (LAMBDA (x y) (CONS x (CONS y NIL))), то 
iнтерпретатор Лiспу видасть повiдомлення про помилку.

Лямбда вираз є як чисто абстрактним механiзмом для визначення та опису 
обчислення, так i механiзмом для зв'язування формальних та фактичних 
параметрiв пiд час виконання обчислення. Лямбда вираз є функцiєю без iменi.

Ми вже говорили про те, як визначити нову функцiю - це можна здiйснити за 
допомогою функцiї DEFUN. Визначення функцiї викликається так:

(DEFUN <iм'я> <лямбда вираз>)

Для спрощення опустимо зовнiшнi дужки у лямбда виразi та сам атом LAMBDA. Тодi
ми отримаємо знайоме нам визначення функцiї. Наступнi визначення еквiвалентнi:

(DEFUN list2 (LAMBDA (x y) (CONS x (CONS y NIL))))
та 
(DEFUN list2         (x y) (CONS x (CONS y NIL)))

Функцiя DEFUN з'єднує символ з лямбда виразом, пiсля чого символ починає 
iменувати обчислення, яке визначається лямбда виразом. Значенням функцiї 
DEFUN є iм'я нової функцiї.

За допомогою структури LET, яка визначена в common.lsp, можна утворити 
локальний звя'зок. Значення змiнним форми LET присвоюються одночасно. Ця 
структура має наступний вигляд:

(LET ((m1 a1) (m2 a2) ... (mN aN)) <форма1> <форма2> ... <формаN>),
яка в дiйсностi є лямбда викликом, де формальнi та фактичнi параметри 
знаходяться разом на початку структури:

((LAMBDA (m1 m2 ... mN) <форма1> <форма2> ... <формаN>) a1 a2 ... aN)

Наступнi виклики еквiвалентнi:

$ (LET ((x 4)(y 2))(+ x y))	$ ((LAMBDA (x y) (+ x y)) 4 2)
6				6

Функцiя типу NLAMBDA називається необчислюваною. Якщо викликається 
необчислювана функцiя, то їй аргументи передаються без обчислення - так, як 
вони стоять в рядку виклику. Пояснимо це на прикладi. Визначимо двi функцiї f1 
та f2, якi на перший погляд однаковi:

(DEFUN f1 (LAMBDA (x y)		(DEFUN f2 (NLAMBDA (x y)
(+ x y)) )			(+ x y)) )

Якщо викликати  (f1 5 6) або (f2 5 6), то результат буде однаковим - 11.
Нехай змiнним k та l присвоєнi деякi значення: (SETQ k 5 l 6). Тодi

$ (f1 k l)	$ (f2 k l)
11		помилка: (+ k l)  / а не (+ 5 6), оскiльки переданi аргументи не обчисленi /

Функцiя типу MACRO називається макро-функцiєю. Макроси є потужним робочим 
iнструментом програмування. Синтаксис визначення макроса виглядає таким же 
чином як синтаксис визначення функцiї форми DEFUN:
(DEFMACRO <iм'я> <лямбда список> <тiло>)

Виклик макроса спiвпадає за формою з викликом функцї, але його обчислення 
вiдрiзняється вiд обчислення виклику функцiї. В макросi не обчислюються 
аргументи. Обчислення виклику макроса складається з двох послiдовних етапiв. 
Спочатку вiдбувається обчислення тiла з аргументами (як i для функцiї). Цей 
етап називається розширенням або розкриттям макроса. На другому етапi 
обчислюється розкрита форма, значення якої повертається в якостi значення 
всього макровиклику. Визначимо макрос PUSH1, який працює як вiдома нам функцiя 
PUSH (в дiйсностi PUSH є вмонтованим в середовище Лiсп макросом).

$ (DEFMACRO PUSH1 (x y)			$ (SETQ 'a '(1 2 3)) (PUSH1 6 'a)
(LIST 'SETQ y (LIST 'CONS x y)))	пiсля чого a = (6 1 2 3)

Визначимо деяку функцiю P, тiлом якої є макрос PUSH1:

(DEFUN p (x y)
(PUSH1 x y))

Тепер за допомогою команди (GETD p) можна побачити, який вигляд має функця p:
(LAMBDA (X Y) (SETQ Y (CONS X Y)))

При програмуваннi розкритого макроса явно не видно, тому для їх тестування 
iснує спецiальна функцiя - MACROEXPAND, яка здiйснює тiльки розкриття макроса. 
Повертається макророзширення виклику, яке можна вивчати.

$ (MACROEXPAND '(PUSH1 6 s))
(SETQ S (CONS 6 S))

CADR-елементом визначення функцiї є або список формальних аргументiв, або iм'я 
формального аргументу. Функцiя, яка визначена за допомогою списку формальних 
аргументiв, в тому числi i порожнього, називається розгорнутою. При виклику 
такої функцiї фактичнi аргументи прив'язуються вiдповiдно до формальних 
аргументiв.

Функцiя, яка визначена за допомогою iменi формального аргумента, називається 
нерозгорнутою. Якщо викликається така функцiя, список фактичних аргументiв 
пов'язується з iменем формального аргумента. Отже нерозгорнутi функцiї 
допускають будь-якi iмена фактичних аргументiв.

CDDR-елементом визначення функцiї є список форм, який називається тiлом 
функцiї. Пiсля того як формальнi аргументи функцiї були прив'язанi з її 
фактичними, починає працювати неявна функцiя PROGN, яка обчислює тiло функцiї.
Пiсля обчислення тiла функцiї формальнi аргументи знову приймають свої вихiднi 
значення, а результат обчислення тiла функцiї видається як значення функцiї.


1. FUNCALL (<функцiя> <arg1> <arg2> ... <argN>)
Виконуються дiї функцiї <функцiя> над аргументами та повертається результат. 
<Функцiя> повинна бути або iменем обчислюваної функцiї, або тiлом LAMBDA. 
Якщо <функцiя> - це iм'я макро або невизначеної функцiї, виникає переривання 
по помилцi <невизначена функцiя>.

$ (FUNCALL 'CONS 'a '(b c d))           $ (FUNCALL '(LAMBDA (n) (* n n)) 5)
(a b c d)                               25


2. EVAL <об'єкт>

Iнтерпретатор Лiспа називається EVAL, його можна як i iншi функцiї викликати з 
програми. У звичайнiй роботi iнтерпретатор викликати не має потреби, оскiльки 
його виклик має мiсце неявно. Зайвий виклик iнтерпретатора може зняти ефект 
блокування (QUOTE), або дозволить знайти значення виразу. EVAL - це 
унiверсальна функцiя Лiспа, яка може обчислити довiльний правильно побудований 
лiсповський вираз.

Якщо об'єкт - атом, функцiя повертає змiст комiрки значення об'єкту. 

Якщо CAR-елемент об'єкта є iменем обчислюваної функцiї або LAMBDA, функцiя 
обчислює кожний елемент CDR-частини об'єкта i додає CAR-елемент об'єкта до 
списку результатiв. 

Якщо CAR-елемент об'єкта є iменем необчислюваної функцiї, EVAL додає 
CAR-елемент об'єкта до CDR-елемента об'єкта без обчислення останнього.

Якщо CAR-елемент об'єкта є макрофункцiєю, EVAL рекурсивно обчислює результат 
додавання CAR-елемента об'єкта до його CDR-елемента.

Якщо CAR-елемент об'єкта не є функцiєю, EVAL повертає помилку "невизначена
функцiя" та генерує переривання по помилцi.

$ (SETQ a 'b b 'c)	$ (EVAL '(CONS 'A '(B C)))	 $ (EVAL '(PRIN1 '(a b c)))
$ (EVAL a)		(A B C)			  	 (a b c) (a b c)
c

$ (DEFUN a (n)		$ (EVAL '(a 3))		$ (EVAL (LAMBDA (n) (* n n)) 7)
(+ n 2)  )		5			49

Дiалог з iнтерпретатором Лiспа на верхньому (командному) рiвнi можна описати 
простим циклом:

(SETQ e (READ))		введення виразу
(SETQ v (EVAL e))	обчислення виразу
(PRINT v)		друк результата

При виконаннi тiла необчислювальної функцiї ми можемо використати функцiю 
EVAL для обчислення аргументiв.

(DEFUN f3 (NLAMBDA (x y)		(SETQ k 5 l 6)	(f3 k l)
(+ (EVAL x) (EVAL y))) )				11


3. CONSTANTP <об'єкт>

Об'єкт є константою тодi i тiльки тодi, коли (EVAL <об'єкт>) повертає <об'єкт>.
Символ NIL, числа та списки, в яких CAR-елемент є символ QUOTE, в muLisp є 
константами. Якщо <об'єкт> - константа, функцiя CONSTANTP повертає Т, 
iнакше - NIL.

$ (CONSTANTP ())	$ (CONSTANTP 23.543)	(DEFUN CONSTANTP (obj)
T			T			((NULL obj))
$ (CONSTANTP 'v)	$ (CONSTANTP '(a b c))	((NUMBERP obj))
NIL			NIL			((ATOM obj) NIL)
$ (CONSTANTP '(QUOTE (a b c)))			(EQ (CAR obj) 'QUOTE)  )
T


4. APPLY <функцiя> <арг1> <арг2> ... <арг-список>

Застосовує функцiю до списку аргументiв. (APPLY f x1 x2 ... xN) еквiвалентно 
(f  x1 x2 ... xN). Використання функцiї APPLY є бiльщ гнучким у порiвняннi з 
прямим викликом функцiї. Дiє як i функцiя FUNCALL, тiльки аргументи функцiї 
приймає не окремо, а списком.

Якщо функцiя - iм'я визначеної користувачем функцiї або тiло LAMBDA, APPLY 
пов'язує формальнi аргументи функцiї з фактичними аргументами, обчислює тiло 
функцiї, вiдтворює вихiднi значення формальних аргументiв i повертає значення 
обчислення тiла функцiї.

Якщо функцiя - не iм'я функцiї i не тiло LAMBDA, APPLY генерує переривання по 
помилцi "невизначена функцiя".

$ (APPLY 'CONS '(a (b c d)))		$ (SETQ z '(LAMBDA (n) (* n n)))
(a b c d)				$ (APPLY z '(4))
16


5. UNDEFINED <символ> <форма1> ... <формаN>

Ця функцiя iнiцiює преривання по помилцi "Невизначена функцiя". Ця функцiя 
керування помилками використовується тодi, коли намагаються обчислити форму, 
CAR-елемент якої є символом, який не має визначення функцiї.



Завдання

1. (PL1 lst1 lst2), де lst1 - список з n чисел, lst2 - список з n - 1 знакiв 
   арифметичних дiй. (PL '(3 6 4 1) '(+ * - ))  - це (3 + 6) * 4 - 1 = 35.

2. Надрукувати всi послiдовностi з k натуральних чисел, у яких i-ий член не 
   перевищує i.

3. Надрукувати всi розстановки дужок в добутку множникiв. Порядок множникiв не 
   змiнюється, дужки однозначно визначають порядок дiй. 
   Наприклад, n=4: ((a b) c) d  (a (b c)) d  a ((b c) d)  (a b)(c d)  
                    a (b (c d)).

4. Написати програму:
а) (INTEGRATE f a b n) - iнтегрування функцiї f вiд a до b; вiдрiзок [a; b] 
			розбити на n частин.
б) (HALFDIV f a b e) - 	знайти корiнь рiвняння f(x)=0, який лежить в iнтервалi
			[a; b] методом половинного дiлення з похибкою e.
в) (SQRT2  n  е) - обчислити квадратний корiнь методом iтерацiї з похибкою е.
г) (DIFF f  x) - обчислити значеняя похiдної функцiї f в точцi x.



Вiдповiдi

1. $ (defun PL1 (lst1 lst2)
      ((NULL lst2) (car lst1))
      (PL1 (cons (funcall (car lst2) (car lst1) (cadr lst1)) (CDDR lst1)) (CDR lst2))  )

2. $ (DEFUN cl (i)
      (SETQ list nil)
      (calc i)  )

   $ (DEFUN calc (i)
       ((ZEROP i) (RETURN (PRINT list)))
       (PUSH i list)
       (LOOP ((> 1 (CAR list)) (RETURN (POP list)))
       (calc (- i 1))
       (PUSH (- (POP list) 1) list)
      )  )

4. а) $  (DEFUN INTEGRATE (function a b n)		(defun f (x)
            (SETQ step (/ (- b a) n) intsumma 0)	(* x x)
            (LOOP					)
     ((= a b) (* intsumma step))
     (INCQ intsumma (FUNCALL function a))	Виклик: (INTEGRATE f 0 1 100)
     (INCQ a step)
)   )

б) (DEFUN HALFDIV (function a b eps)
     (SETQ middle (/ (+ a b) 2) res (FUNCALL function middle))
     ((< (- b a) eps) middle)
     (IF (MINUSP (* res (FUNCALL function a)))
(HALFDIV function a middle eps) (HALFDIV function middle b eps))
   )

в) $ (DEFUN SQRT2 (n eps) 		г) $ (DEFUN DIFF (function x)
       (SETQ s (/ n 2))				       (SETQ delta 0.01)
       (LOOP					       (/ (- (FUNCALL function (+ x delta))
	(SETQ snew (/ (+ s (/ n s)) 2))	 		(FUNCALL function x)) delta)
	((< (ABS(- s snew)) eps) snew) 	     )
	      (SETQ s snew)					
      )   )
Вказiвка: x1 = n/2, xi = (xi-1 + n/xi-1) / 2.	f'(x) =  (f(x + dx) - f(x)) / dx, де dx = 0.001.


